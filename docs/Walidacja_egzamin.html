<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Egzaminy - Metody Walidacji Modeli Statystycznych</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./Eksploracja_egzamin.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./Walidacja_egzamin.html">Metody Walidacji Modeli Statystycznych</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Egzaminy</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Losowanie</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./WAD_egzamin.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Wielowymiarowa analiza danych</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Modele_egzamin.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Statystyczne Modele Liniowe i Nieliniowe</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Eksploracja_egzamin.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Eksploracja Danych</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./Walidacja_egzamin.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Metody Walidacji Modeli Statystycznych</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#zagadnienia-do-przygotowania-na-egzamin-ustny-z-metod-walidacji-modeli-statystycznych" id="toc-zagadnienia-do-przygotowania-na-egzamin-ustny-z-metod-walidacji-modeli-statystycznych" class="nav-link active" data-scroll-target="#zagadnienia-do-przygotowania-na-egzamin-ustny-z-metod-walidacji-modeli-statystycznych">Zagadnienia do przygotowania na egzamin ustny z Metod Walidacji Modeli Statystycznych</a>
  <ul class="collapse">
  <li><a href="#opisz-typy-modeli-statystycznych-w-podziale-na-przeznaczenie.-wymień-po-jednym-przykładzie-dla-każdego-typu." id="toc-opisz-typy-modeli-statystycznych-w-podziale-na-przeznaczenie.-wymień-po-jednym-przykładzie-dla-każdego-typu." class="nav-link" data-scroll-target="#opisz-typy-modeli-statystycznych-w-podziale-na-przeznaczenie.-wymień-po-jednym-przykładzie-dla-każdego-typu.">1. Opisz typy modeli statystycznych w podziale na przeznaczenie. Wymień po jednym przykładzie dla każdego typu.</a></li>
  <li><a href="#opisz-proces-tworzenia-modelu-statystycznego." id="toc-opisz-proces-tworzenia-modelu-statystycznego." class="nav-link" data-scroll-target="#opisz-proces-tworzenia-modelu-statystycznego.">2. Opisz proces tworzenia modelu statystycznego.</a></li>
  <li><a href="#opisz-zasadę-działania-testów-bootstrapowych." id="toc-opisz-zasadę-działania-testów-bootstrapowych." class="nav-link" data-scroll-target="#opisz-zasadę-działania-testów-bootstrapowych.">3. Opisz zasadę działania testów bootstrapowych.</a></li>
  <li><a href="#opisz-zasadę-działania-testów-permutacyjnych." id="toc-opisz-zasadę-działania-testów-permutacyjnych." class="nav-link" data-scroll-target="#opisz-zasadę-działania-testów-permutacyjnych.">4. Opisz zasadę działania testów permutacyjnych.</a></li>
  <li><a href="#podaj-podział-miar-dopasowania-modeli-predykcyjnych-oraz-wymień-po-trzy-miary-dedykowane-do-modeli-regresyjnych." id="toc-podaj-podział-miar-dopasowania-modeli-predykcyjnych-oraz-wymień-po-trzy-miary-dedykowane-do-modeli-regresyjnych." class="nav-link" data-scroll-target="#podaj-podział-miar-dopasowania-modeli-predykcyjnych-oraz-wymień-po-trzy-miary-dedykowane-do-modeli-regresyjnych.">5. Podaj podział miar dopasowania modeli predykcyjnych oraz wymień po trzy miary dedykowane do modeli regresyjnych.</a></li>
  <li><a href="#podaj-podział-miar-dopasowania-modeli-predykcyjnych-oraz-wymień-po-trzy-miary-dedykowane-do-modeli-klasyfikacyjnych." id="toc-podaj-podział-miar-dopasowania-modeli-predykcyjnych-oraz-wymień-po-trzy-miary-dedykowane-do-modeli-klasyfikacyjnych." class="nav-link" data-scroll-target="#podaj-podział-miar-dopasowania-modeli-predykcyjnych-oraz-wymień-po-trzy-miary-dedykowane-do-modeli-klasyfikacyjnych.">6. Podaj podział miar dopasowania modeli predykcyjnych oraz wymień po trzy miary dedykowane do modeli klasyfikacyjnych.</a></li>
  <li><a href="#podaj-miary-dopasowania-modeli-ze-zmienną-zależną-wieloklasową." id="toc-podaj-miary-dopasowania-modeli-ze-zmienną-zależną-wieloklasową." class="nav-link" data-scroll-target="#podaj-miary-dopasowania-modeli-ze-zmienną-zależną-wieloklasową.">7. Podaj miary dopasowania modeli ze zmienną zależną wieloklasową.</a></li>
  <li><a href="#sec-roc_auc" id="toc-sec-roc_auc" class="nav-link" data-scroll-target="#sec-roc_auc">8. Opisz czym jest krzywa ROC i miara AUC.</a></li>
  <li><a href="#opisz-do-czego-jest-stosowany-podział-na-próbę-uczącą-i-testową-oraz-opisz-jak-można-przeprowadzić-podział-na-co-wpływa-proporcja-podziału-jak-ją-można-ustalić." id="toc-opisz-do-czego-jest-stosowany-podział-na-próbę-uczącą-i-testową-oraz-opisz-jak-można-przeprowadzić-podział-na-co-wpływa-proporcja-podziału-jak-ją-można-ustalić." class="nav-link" data-scroll-target="#opisz-do-czego-jest-stosowany-podział-na-próbę-uczącą-i-testową-oraz-opisz-jak-można-przeprowadzić-podział-na-co-wpływa-proporcja-podziału-jak-ją-można-ustalić.">9. Opisz do czego jest stosowany podział na próbę uczącą i testową oraz opisz jak można przeprowadzić podział, na co wpływa proporcja podziału, jak ją można ustalić.</a></li>
  <li><a href="#na-czym-polega-ekstrakcja-cech-podaj-przykłady-dwóch-technik-z-tego-zakresu." id="toc-na-czym-polega-ekstrakcja-cech-podaj-przykłady-dwóch-technik-z-tego-zakresu." class="nav-link" data-scroll-target="#na-czym-polega-ekstrakcja-cech-podaj-przykłady-dwóch-technik-z-tego-zakresu.">10. Na czym polega ekstrakcja cech? Podaj przykłady dwóch technik z tego zakresu.</a></li>
  <li><a href="#czym-jest-walidacja-krzyżowa-i-walidacja-krzyżowa-z-powtórzeniami" id="toc-czym-jest-walidacja-krzyżowa-i-walidacja-krzyżowa-z-powtórzeniami" class="nav-link" data-scroll-target="#czym-jest-walidacja-krzyżowa-i-walidacja-krzyżowa-z-powtórzeniami">11. Czym jest walidacja krzyżowa i walidacja krzyżowa z powtórzeniami?</a></li>
  <li><a href="#czym-jest-metoda-leave-one-out" id="toc-czym-jest-metoda-leave-one-out" class="nav-link" data-scroll-target="#czym-jest-metoda-leave-one-out">12. Czym jest metoda Leave-One-Out?</a></li>
  <li><a href="#czym-jest-walidacja-metodą-monte-carlo" id="toc-czym-jest-walidacja-metodą-monte-carlo" class="nav-link" data-scroll-target="#czym-jest-walidacja-metodą-monte-carlo">13. Czym jest walidacja metodą Monte-Carlo?</a></li>
  <li><a href="#jak-stosujemy-bootstraping-do-walidacji-modeli" id="toc-jak-stosujemy-bootstraping-do-walidacji-modeli" class="nav-link" data-scroll-target="#jak-stosujemy-bootstraping-do-walidacji-modeli">14. Jak stosujemy bootstraping do walidacji modeli?</a></li>
  <li><a href="#czym-jest-i-do-czego-stosujemy-próbkowanie-kroczące" id="toc-czym-jest-i-do-czego-stosujemy-próbkowanie-kroczące" class="nav-link" data-scroll-target="#czym-jest-i-do-czego-stosujemy-próbkowanie-kroczące">15. Czym jest i do czego stosujemy próbkowanie kroczące?</a></li>
  <li><a href="#na-czym-polega-optymalizacja-modeli-predykcyjnych" id="toc-na-czym-polega-optymalizacja-modeli-predykcyjnych" class="nav-link" data-scroll-target="#na-czym-polega-optymalizacja-modeli-predykcyjnych">16. Na czym polega optymalizacja modeli predykcyjnych?</a></li>
  <li><a href="#przedstaw-zasadę-działania-dwóch-sposobów-podejścia-do-tuningu-modeli." id="toc-przedstaw-zasadę-działania-dwóch-sposobów-podejścia-do-tuningu-modeli." class="nav-link" data-scroll-target="#przedstaw-zasadę-działania-dwóch-sposobów-podejścia-do-tuningu-modeli.">17. Przedstaw zasadę działania dwóch sposobów podejścia do tuningu modeli.</a></li>
  <li><a href="#opisz-przeszukiwanie-z-wykorzystaniem-siatki-regularnej-i-nieregularnej." id="toc-opisz-przeszukiwanie-z-wykorzystaniem-siatki-regularnej-i-nieregularnej." class="nav-link" data-scroll-target="#opisz-przeszukiwanie-z-wykorzystaniem-siatki-regularnej-i-nieregularnej.">18. Opisz przeszukiwanie z wykorzystaniem siatki regularnej i nieregularnej.</a></li>
  <li><a href="#opisz-zasadę-wykorzystania-wielu-rdzeni-procesora-w-optymalizacji-modelu." id="toc-opisz-zasadę-wykorzystania-wielu-rdzeni-procesora-w-optymalizacji-modelu." class="nav-link" data-scroll-target="#opisz-zasadę-wykorzystania-wielu-rdzeni-procesora-w-optymalizacji-modelu.">19. Opisz zasadę wykorzystania wielu rdzeni procesora w optymalizacji modelu.</a></li>
  <li><a href="#czym-jest-metoda-wyścigów" id="toc-czym-jest-metoda-wyścigów" class="nav-link" data-scroll-target="#czym-jest-metoda-wyścigów">20. Czym jest metoda wyścigów?</a></li>
  <li><a href="#czym-jest-przeszukiwanie-iteracyjne" id="toc-czym-jest-przeszukiwanie-iteracyjne" class="nav-link" data-scroll-target="#czym-jest-przeszukiwanie-iteracyjne">21. Czym jest przeszukiwanie iteracyjne?</a></li>
  <li><a href="#sec-bayes" id="toc-sec-bayes" class="nav-link" data-scroll-target="#sec-bayes">22. Opisz optymalizację bayesowską.</a></li>
  <li><a href="#czym-są-procesy-gaussowskie" id="toc-czym-są-procesy-gaussowskie" class="nav-link" data-scroll-target="#czym-są-procesy-gaussowskie">23. Czym są procesy gaussowskie?</a></li>
  <li><a href="#co-to-jest-funkcja-akwizycji" id="toc-co-to-jest-funkcja-akwizycji" class="nav-link" data-scroll-target="#co-to-jest-funkcja-akwizycji">24. Co to jest funkcja akwizycji?</a></li>
  <li><a href="#sec-annealing" id="toc-sec-annealing" class="nav-link" data-scroll-target="#sec-annealing">25. Opisz zasadę działania metody symulowanego wyżarzania.</a></li>
  <li><a href="#przedstaw-powody-stosowania-redukcji-wymiarowości." id="toc-przedstaw-powody-stosowania-redukcji-wymiarowości." class="nav-link" data-scroll-target="#przedstaw-powody-stosowania-redukcji-wymiarowości.">26. Przedstaw powody stosowania redukcji wymiarowości.</a></li>
  <li><a href="#jakie-są-powody-stosowania-podpróbkowania-i-nadpróbkowania-w-modelowaniu-predykcyjnym" id="toc-jakie-są-powody-stosowania-podpróbkowania-i-nadpróbkowania-w-modelowaniu-predykcyjnym" class="nav-link" data-scroll-target="#jakie-są-powody-stosowania-podpróbkowania-i-nadpróbkowania-w-modelowaniu-predykcyjnym">27. Jakie są powody stosowania podpróbkowania i nadpróbkowania w modelowaniu predykcyjnym?</a></li>
  <li><a href="#jakie-są-korzyści-ze-stosowania-próbkowania-zaniżającego-liczebność-klasy-większościowej" id="toc-jakie-są-korzyści-ze-stosowania-próbkowania-zaniżającego-liczebność-klasy-większościowej" class="nav-link" data-scroll-target="#jakie-są-korzyści-ze-stosowania-próbkowania-zaniżającego-liczebność-klasy-większościowej">28. Jakie są korzyści ze stosowania próbkowania zaniżającego liczebność klasy większościowej?</a></li>
  <li><a href="#jakie-są-zalety-próbkowania-zawyżającego-liczebność-klasy-mniejszościowej" id="toc-jakie-są-zalety-próbkowania-zawyżającego-liczebność-klasy-mniejszościowej" class="nav-link" data-scroll-target="#jakie-są-zalety-próbkowania-zawyżającego-liczebność-klasy-mniejszościowej">29. Jakie są zalety próbkowania zawyżającego liczebność klasy mniejszościowej?</a></li>
  <li><a href="#jak-należy-stosować-poszczególne-kroki-przygotowania-danych-w-procesie-uczenia-i-walidacji-modelu" id="toc-jak-należy-stosować-poszczególne-kroki-przygotowania-danych-w-procesie-uczenia-i-walidacji-modelu" class="nav-link" data-scroll-target="#jak-należy-stosować-poszczególne-kroki-przygotowania-danych-w-procesie-uczenia-i-walidacji-modelu">30. Jak należy stosować poszczególne kroki przygotowania danych w procesie uczenia i walidacji modelu?</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Metody Walidacji Modeli Statystycznych</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="zagadnienia-do-przygotowania-na-egzamin-ustny-z-metod-walidacji-modeli-statystycznych" class="level1">
<h1>Zagadnienia do przygotowania na egzamin ustny z Metod Walidacji Modeli Statystycznych</h1>
<!-- ![](obrazki/overfit2.jpeg) -->
<p><img src="obrazki/ML.webp" class="img-fluid"></p>
<hr>
<section id="opisz-typy-modeli-statystycznych-w-podziale-na-przeznaczenie.-wymień-po-jednym-przykładzie-dla-każdego-typu." class="level2">
<h2 class="anchored" data-anchor-id="opisz-typy-modeli-statystycznych-w-podziale-na-przeznaczenie.-wymień-po-jednym-przykładzie-dla-każdego-typu.">1. Opisz typy modeli statystycznych w podziale na przeznaczenie. Wymień po jednym przykładzie dla każdego typu.</h2>
<ol type="1">
<li><strong>Modele opisowe</strong></li>
</ol>
<p>Celem modelu opisowego jest opis lub zilustrowanie pewnych cech danych. Analiza może nie mieć innego celu niż wizualne podkreślenie jakiegoś trendu lub artefaktu (lub defektu) w danych. <br> <u>Przykład</u>: Pomiary RNA na dużą skalę są możliwe od pewnego czasu przy użyciu mikromacierzy. Wczesne metody laboratoryjne umieszczały próbkę biologiczną na małym mikrochipie. Bardzo małe miejsca na chipie mogą mierzyć sygnał oparty na bogactwie specyficznej sekwencji RNA. Chip zawierałby tysiące (lub więcej) wyników, z których każdy byłby kwantyfikacją RNA związanego z procesem biologicznym. Jednakże na chipie mogłyby wystąpić problemy z jakością, które mogłyby prowadzić do słabych wyników. Na przykład, odcisk palca przypadkowo pozostawiony na części chipa mógłby spowodować niedokładne pomiary podczas skanowania.</p>
<p><img src="obrazki/rna.png" class="img-fluid"></p>
<p>Wczesną metodą oceny takich zagadnień były modele na poziomie sondy, czyli PLM. Tworzono model statystyczny, który uwzględniał pewne różnice w danych, takie jak chip, sekwencja RNA, typ sekwencji i tak dalej. Jeśli w danych występowałyby inne, nieznane czynniki, to efekty te zostałyby uchwycone w resztach modelu. Gdy reszty zostały wykreślone według ich lokalizacji na chipie, dobrej jakości chip nie wykazywałby żadnych wzorców. W przypadku wystąpienia problemu, pewien rodzaj wzorca przestrzennego byłby dostrzegalny. Często typ wzorca sugerowałby problem (np. odcisk palca) oraz możliwe rozwiązanie (wytarcie chipa i ponowne skanowanie, powtórzenie próbki, itp.) Rysunek pokazuje zastosowanie tej metody dla dwóch mikromacierzy. Obrazy pokazują dwie różne wartości kolorystyczne; obszary, które są ciemniejsze to miejsca, gdzie intensywność sygnału była większa niż oczekuje model, podczas gdy jaśniejszy kolor pokazuje wartości niższe niż oczekiwane. Lewy panel pokazuje w miarę losowy wzór, podczas gdy prawy panel wykazuje niepożądany artefakt w środku chipa.</p>
<ol start="2" type="1">
<li><strong>Modele do wnioskowania</strong></li>
</ol>
Celem modelu inferencyjnego jest podjęcie decyzji dotyczącej pytania badawczego lub sprawdzenie określonej hipotezy, podobnie jak w przypadku testów statystycznych. Model inferencyjny zaczyna się od wcześniej zdefiniowanego przypuszczenia lub pomysłu na temat populacji i tworzy wniosek statystyczny, taki jak szacunek przedziału lub odrzucenie hipotezy. <br> <u>Przykład</u>: celem badania klinicznego może być potwierdzenie, że nowa terapia pozwala wydłużyć życie w porównaniu z istniejącą terapią lub brakiem leczenia. Jeśli kliniczny punkt końcowy dotyczyłby przeżycia pacjenta, hipoteza zerowa mogłaby brzmieć, że nowa terapia ma równą lub niższą medianę czasu przeżycia, a hipoteza alternatywna, że nowa terapia ma wyższą medianę czasu przeżycia. Jeśli ta próba byłaby oceniana przy użyciu tradycyjnego testowania istotności hipotezy zerowej poprzez modelowanie, testowanie istotności dałoby wartość <span class="math inline">\(p\)</span> przy użyciu jakiejś wcześniej zdefiniowanej metodologii opartej na zestawie założeń. Małe wartości dla wartości <span class="math inline">\(p\)</span> w wynikach modelu wskazywałyby na istnienie przesłanek, że nowa terapia pomaga pacjentom żyć dłużej. Duże wartości <span class="math inline">\(p\)</span> w wynikach modelu wskazywałyby, że nie udało się wykazać takiej różnicy; ten brak przesłanek mógłby wynikać z wielu powodów, w tym z tego, że terapia nie działa.
<p style="color:#808080">
Techniki modelowania inferencyjnego zazwyczaj dają pewien rodzaj danych wyjściowych o charakterze probabilistycznym, takich jak wartość <span class="math inline">\(p\)</span>, przedział ufności lub prawdopodobieństwo <em>a posteriori</em>. Zatem, aby obliczyć taką wielkość, należy przyjąć formalne założenia probabilistyczne dotyczące danych i procesów, które je wygenerowały. Jakość wyników modelowania statystycznego w dużym stopniu zależy od tych wcześniej określonych założeń, jak również od tego, w jakim stopniu obserwowane dane wydają się z nimi zgadzać. Najbardziej krytycznymi czynnikami są tutaj założenia teoretyczne: “Jeśli moje obserwacje były niezależne, a reszty mają rozkład X, to statystyka testowa Y może być użyta do uzyskania wartości <span class="math inline">\(p\)</span>. W przeciwnym razie wynikowa wartość <span class="math inline">\(p\)</span> może być niewłaściwa.” <br> Jednym z aspektów analiz inferencyjnych jest to, że istnieje tendencja do opóźnionego sprzężenia zwrotnego w zrozumieniu, jak dobrze dane odpowiadają założeniom modelu. W naszym przykładzie badania klinicznego, jeśli znaczenie statystyczne (i kliniczne) wskazuje, że nowa terapia powinna być dostępna do stosowania przez pacjentów, mogą minąć lata zanim zostanie ona zastosowana w terenie i zostanie wygenerowana wystarczająca ilość danych do niezależnej oceny, czy pierwotna analiza statystyczna doprowadziła do podjęcia właściwej decyzji.
</p>
<ol start="3" type="1">
<li><strong>Modele predykcyjne</strong></li>
</ol>
<p>Celem modelu predykcyjnego jest uzyskanie jak najdokładniejszej prognozy dla nowych danych. W tym przypadku głównym celem jest, aby przewidywane wartości (ang. <em>prediction</em>) miały najwyższą możliwą zgodność z prawdziwą wartością (ang. <em>observed</em>).</p>
<br> <u>Przykład</u>: Prostym przykładem może być przewidywanie przez sprzedającego książki, ile egzemplarzy danej książki powinno być zamówionych do jego sklepu w następnym miesiącu. Nadmierna prognoza powoduje marnowanie miejsca i pieniędzy z powodu nadmiaru książek. Jeśli przewidywanie jest mniejsze niż powinno, następuje utrata potencjału i mniejszy zysk.
<p style="color:#808080">
Celem tego typu modeli jest raczej estymacja niż wnioskowanie. Na przykład nabywca zwykle nie jest zainteresowany pytaniem typu “Czy w przyszłym miesiącu sprzedam więcej niż 100 egzemplarzy książki X?”, ale raczej “Ile egzemplarzy książki X klienci kupią w przyszłym miesiącu?”. Również, w zależności od kontekstu, może nie być zainteresowania tym, dlaczego przewidywana wartość wynosi X. Innymi słowy, bardziej interesuje go sama wartość niż ocena formalnej hipotezy związanej z danymi. Prognoza może również zawierać miary niepewności. W przypadku nabywcy książek podanie błędu prognozy może być pomocne przy podejmowaniu decyzji, ile książek należy kupić. Może też służyć jako metryka pozwalająca ocenić, jak dobrze zadziałała metoda predykcji. <br> Jakie są najważniejsze czynniki wpływające na modele predykcyjne? Istnieje wiele różnych sposobów, w jaki można stworzyć model predykcyjny, dlatego w ocenie wpływu poszczególnych czynników kluczowej jest to jak model został opracowany.
</p>
<p><u>Model mechanistyczny</u> może być wyprowadzony przy użyciu podstawowych zasad w celu uzyskania równania modelowego, które zależy od pewnych założeń. Na przykład przy przewidywaniu ilości leku, która znajduje się w organizmie danej osoby w określonym czasie, przyjmuje się pewne formalne założenia dotyczące sposobu podawania, wchłaniania, metabolizowania i eliminacji leku. Na tej podstawie można wykorzystać układ równań różniczkowych do wyprowadzenia określonego równania modelowego. Dane są wykorzystywane do oszacowania nieznanych parametrów tego równania, tak aby można było wygenerować prognozy. Podobnie jak modele inferencyjne, mechanistyczne modele predykcyjne w dużym stopniu zależą od założeń, które definiują ich równania modelowe. Jednakże, w przeciwieństwie do modeli inferencyjnych, łatwo jest formułować oparte na danych stwierdzenia dotyczące tego, jak dobrze model działa, na podstawie tego, jak dobrze przewiduje istniejące dane. W tym przypadku pętla sprzężenia zwrotnego dla osoby zajmującej się modelowaniem jest znacznie szybsza niż w przypadku testowania hipotez. <br> <u>Modele empiryczne</u> są tworzone przy bardziej niejasnych założeniach. Modele te należą zwykle do kategorii uczenia maszynowego. Dobrym przykładem jest model K-najbliższych sąsiadów (KNN). Biorąc pod uwagę zestaw danych referencyjnych, nowa obserwacja jest przewidywana przy użyciu wartości K najbardziej podobnych danych w zestawie referencyjnym. Na przykład, jeśli kupujący książkę potrzebuje prognozy dla nowej książki, a dodatkowo posiada dane historyczne o istniejących książkach, wówczas model 5-najbliższych sąsiadów może posłużyć do estymacji liczby nowych książek do zakupu na podstawie liczby sprzedaży pięciu książek, które są najbardziej podobne do nowej książki (dla pewnej definicji “podobnej”). Model ten jest zdefiniowany jedynie przez samą funkcję predykcji (średnia z pięciu podobnych książek). Nie przyjmuje się żadnych teoretycznych lub probabilistycznych założeń dotyczących sprzedaży lub zmiennych, które są używane do określenia podobieństwa pomiędzy książkami. W rzeczywistości podstawową metodą oceny adekwatności modelu jest ocena jego precyzji przy użyciu istniejących danych. Jeśli model jest dobrym wyborem, predykcje powinny być zbliżone do wartości rzeczywistych.</p>
<details>
<summary>
<strong>Związki między typami modeli</strong>
</summary>
<p>Zwykły model regresji może należeć do którejś z tych trzech klas modeli, w zależności od sposobu jego wykorzystania:</p>
<ul>
<li><p>model regresji liniowej może być użyty do opisania trendów w danych;</p></li>
<li><p>model analizy wariancji (ANOVA) jest specjalnym rodzajem modelu liniowego, który może być użyty do wnioskowania o prawdziwości hipotezy;</p></li>
<li><p>model regresji liniowej wykorzystywany jako model predykcyjny.</p></li>
</ul>
<p>Istnieje dodatkowy związek między typami modeli, ponieważ konstrukcje, których celem był opis zjawiska lub wnioskowanie o nim, nie są zwykle wykorzystywane do predykcji, to nie należy całkowicie ignorować ich zdolności predykcyjnych. W przypadku pierwszych dwóch typów modeli, badacz skupia się głównie na wyselekcjonowaniu statystycznie istotnych zmiennych w modelu oraz spełnieniu szeregu założeń pozwalających na bezpieczne wnioskowanie. Takie podejście może być niebezpieczne, gdy istotność statystyczna jest używana jako jedyna miara jakości modelu. Jest możliwe, że ten statystycznie zoptymalizowany model ma słabą dokładność wyrażoną pewną miarą dopasowania.</p>
<p>Istnieje również podział samych modeli uczenia maszynowego. Po pierwsze, wiele modeli można skategoryzować jako nadzorowane lub nienadzorowane. Modele nienadzorowane to takie, które uczą się wzorców, skupisk lub innych cech danych, ale nie mają zmiennej wynikowej (nauczyciela). Analiza głównych składowych (PCA), analiza skupień czy autoenkodery są przykładami modeli nienadzorowanych; są one używane do zrozumienia relacji pomiędzy zmiennymi lub zestawami zmiennych bez wyraźnego związku pomiędzy predyktorami i wynikiem. Modele nadzorowane to takie, które mają zmienną wynikową. Regresja liniowa, sieci neuronowe i wiele innych metodologii należą do tej kategorii.</p>
<p>W ramach modeli nadzorowanych można wyróżnić dwie główne podkategorie:</p>
<ul>
<li><p><u>regresyjne</u> - przewidujące zmienną wynikową będącą zmienną o charakterze ilościowym;</p></li>
<li><p><u>klasyfikacyjne</u> - przewidujące zmienną wynikową będącą zmienną o charakterze jakościowym.</p></li>
</ul>
<p>Różne zmienne modelu mogą pełnić różne role, zwłaszcza w nadzorowanym uczeniu maszynowym. Zmienna zależna lub objaśniana (ang. outcome) to wartość przewidywana w modelach nadzorowanych. Zmienne niezależne, które są podłożem do tworzenia przewidywań wyniku, są również określane jako predyktory, cechy lub kowarianty (w zależności od kontekstu).</p>
<p><br></p>
</details></section>
<section id="opisz-proces-tworzenia-modelu-statystycznego." class="level2">
<h2 class="anchored" data-anchor-id="opisz-proces-tworzenia-modelu-statystycznego.">2. Opisz proces tworzenia modelu statystycznego.</h2>
<ol type="1">
<li>Czyszczenie danych
<p style="color:#808080">
Po pierwsze, należy pamiętać o chronicznie niedocenianym procesie czyszczenia danych. Bez względu na okoliczności, należy przeanalizować dane pod kątem tego, czy są one odpowiednie do celów projektu i czy są właściwe. Te kroki mogą z łatwością zająć więcej czasu niż cała reszta procesu analizy danych (w zależności od okoliczności).
</p></li>
<li>Eksploracyjna Analiza Danych (ang. <em>exploratory data analysis</em> - EDA)
<p style="color:#808080">
EDA wydobywa na światło dzienne to, jak różne zmienne są ze sobą powiązane, ich rozkłady, typowe zakresy zmienności i inne atrybuty. Dobrym pytaniem, które należy zadać w tej fazie, jest “Jak dotarłem do tych danych?”. To pytanie może pomóc zrozumieć, w jaki sposób dane, o których mowa, były próbkowane lub filtrowane i czy te operacje były właściwe. Na przykład podczas łączenia tabel bazy danych może dojść do nieudanego złączenia, które może przypadkowo wyeliminować jedną lub więcej subpopulacji.
</p></li>
<li>Identyfikacja metryk
<p style="color:#808080">
Należy zidentyfikować przynajmniej jedną metrykę wydajności z realistycznymi celami dotyczącymi tego, co można osiągnąć. Typowe metryki statystyczne, to dokładność klasyfikacji (ang. <em>accuracy</em>), odsetek poprawnie i niepoprawnie zaklasyfikowanych sukcesów (przez sukces rozumiemy wyróżnioną klasę), pierwiastek błędu średniokwadratowego i tak dalej. Należy rozważyć względne korzyści i wady tych metryk. Ważne jest również, aby metryka była zgodna z szerszymi celami analizy danych.
</p></li>
</ol>
<p><img src="obrazki/model1.png" class="img-fluid"></p>
<p>W ramach czynności zaznaczonych na szarym polu możemy wyróżnić:</p>
<ul>
<li><p><u>eksploracyjna analiza danych (EDA)</u> - to kombinacja pewnych obliczeń statystycznych i wizualizacji, w celu odpowiedzi na podstawowe pytania i postawienia kolejnych. Przykładowo jeśli na wykresie histogramu lub gęstości zmiennej wynikowej w zadaniu regresyjnym zauważymy wyraźną dwumodalność, to może ona świadczyć, że badana zbiorowość nie jest homogeniczna w kontekście analizowanej zmiennej, a co w konsekwencji może skłonić nas do oddzielnego modelowania zjawisk w każdej z podpopulacji.</p></li>
<li><p><u>inżynieria cech (ang. <em>feature engineering</em>)</u> - zespół czynności mający na celu transformację i selekcję cech w procesie budowania modelu.</p></li>
<li><p><u>tuning modeli</u> - zespół czynności mający na celu optymalizację hiperparametrów modeli, poprzez wybór różnych ich konfiguracji oraz porównanie efektów uczenia.</p></li>
<li><p><u>ocena dopasowania modeli</u> - ocena jakości otrzymanych modeli na podstawie miar oraz wykresów diagnostycznych.</p></li>
</ul>
<p><img src="obrazki/model2.png" class="img-fluid"></p>
<p style="color:#808080">
Przykładowo w pracy Kuhn i Johnson (2021) autorzy badając natężenie ruchu kolei publicznej w Chicago, przeprowadzili następujące rozumowanie podczas budowy modelu (oryginalna pisownia):
</p>
<div class="cell">
<div class="cell-output-display">

<div id="eakeqvepqi" style="padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;">
<style>#eakeqvepqi table {
  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#eakeqvepqi thead, #eakeqvepqi tbody, #eakeqvepqi tfoot, #eakeqvepqi tr, #eakeqvepqi td, #eakeqvepqi th {
  border-style: none;
}

#eakeqvepqi p {
  margin: 0;
  padding: 0;
}

#eakeqvepqi .gt_table {
  display: table;
  border-collapse: collapse;
  line-height: normal;
  margin-left: auto;
  margin-right: auto;
  color: #333333;
  font-size: 16px;
  font-weight: normal;
  font-style: normal;
  background-color: #FFFFFF;
  width: auto;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #A8A8A8;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #A8A8A8;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
}

#eakeqvepqi .gt_caption {
  padding-top: 4px;
  padding-bottom: 4px;
}

#eakeqvepqi .gt_title {
  color: #333333;
  font-size: 125%;
  font-weight: initial;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-color: #FFFFFF;
  border-bottom-width: 0;
}

#eakeqvepqi .gt_subtitle {
  color: #333333;
  font-size: 85%;
  font-weight: initial;
  padding-top: 3px;
  padding-bottom: 5px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-color: #FFFFFF;
  border-top-width: 0;
}

#eakeqvepqi .gt_heading {
  background-color: #FFFFFF;
  text-align: center;
  border-bottom-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#eakeqvepqi .gt_bottom_border {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#eakeqvepqi .gt_col_headings {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#eakeqvepqi .gt_col_heading {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 6px;
  padding-left: 5px;
  padding-right: 5px;
  overflow-x: hidden;
}

#eakeqvepqi .gt_column_spanner_outer {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 4px;
  padding-right: 4px;
}

#eakeqvepqi .gt_column_spanner_outer:first-child {
  padding-left: 0;
}

#eakeqvepqi .gt_column_spanner_outer:last-child {
  padding-right: 0;
}

#eakeqvepqi .gt_column_spanner {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 5px;
  overflow-x: hidden;
  display: inline-block;
  width: 100%;
}

#eakeqvepqi .gt_spanner_row {
  border-bottom-style: hidden;
}

#eakeqvepqi .gt_group_heading {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  text-align: left;
}

#eakeqvepqi .gt_empty_group_heading {
  padding: 0.5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: middle;
}

#eakeqvepqi .gt_from_md > :first-child {
  margin-top: 0;
}

#eakeqvepqi .gt_from_md > :last-child {
  margin-bottom: 0;
}

#eakeqvepqi .gt_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  margin: 10px;
  border-top-style: solid;
  border-top-width: 1px;
  border-top-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  overflow-x: hidden;
}

#eakeqvepqi .gt_stub {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
}

#eakeqvepqi .gt_stub_row_group {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  vertical-align: top;
}

#eakeqvepqi .gt_row_group_first td {
  border-top-width: 2px;
}

#eakeqvepqi .gt_row_group_first th {
  border-top-width: 2px;
}

#eakeqvepqi .gt_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#eakeqvepqi .gt_first_summary_row {
  border-top-style: solid;
  border-top-color: #D3D3D3;
}

#eakeqvepqi .gt_first_summary_row.thick {
  border-top-width: 2px;
}

#eakeqvepqi .gt_last_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#eakeqvepqi .gt_grand_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#eakeqvepqi .gt_first_grand_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: double;
  border-top-width: 6px;
  border-top-color: #D3D3D3;
}

#eakeqvepqi .gt_last_grand_summary_row_top {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: double;
  border-bottom-width: 6px;
  border-bottom-color: #D3D3D3;
}

#eakeqvepqi .gt_striped {
  background-color: rgba(128, 128, 128, 0.05);
}

#eakeqvepqi .gt_table_body {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#eakeqvepqi .gt_footnotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#eakeqvepqi .gt_footnote {
  margin: 0px;
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#eakeqvepqi .gt_sourcenotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#eakeqvepqi .gt_sourcenote {
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#eakeqvepqi .gt_left {
  text-align: left;
}

#eakeqvepqi .gt_center {
  text-align: center;
}

#eakeqvepqi .gt_right {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

#eakeqvepqi .gt_font_normal {
  font-weight: normal;
}

#eakeqvepqi .gt_font_bold {
  font-weight: bold;
}

#eakeqvepqi .gt_font_italic {
  font-style: italic;
}

#eakeqvepqi .gt_super {
  font-size: 65%;
}

#eakeqvepqi .gt_footnote_marks {
  font-size: 75%;
  vertical-align: 0.4em;
  position: initial;
}

#eakeqvepqi .gt_asterisk {
  font-size: 100%;
  vertical-align: 0;
}

#eakeqvepqi .gt_indent_1 {
  text-indent: 5px;
}

#eakeqvepqi .gt_indent_2 {
  text-indent: 10px;
}

#eakeqvepqi .gt_indent_3 {
  text-indent: 15px;
}

#eakeqvepqi .gt_indent_4 {
  text-indent: 20px;
}

#eakeqvepqi .gt_indent_5 {
  text-indent: 25px;
}
</style>
<table class="gt_table" data-quarto-disable-processing="false" data-quarto-bootstrap="false">
  <thead>
    
    <tr class="gt_col_headings">
      <th class="gt_col_heading gt_columns_bottom_border gt_left" rowspan="1" colspan="1" style="color: #7F7F7F;" scope="col" id="Thoughts">Thoughts</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_left" rowspan="1" colspan="1" style="color: #7F7F7F;" scope="col" id="Activity">Activity</th>
    </tr>
  </thead>
  <tbody class="gt_table_body">
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">The daily ridership values between stations are extremely correlated.</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">EDA</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">Weekday and weekend ridership look very different.</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">EDA</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">One day in the summer of 2010 has an abnormally large number of riders.</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">EDA</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">Which stations had the lowest daily ridership values?</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">EDA</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">Dates should at least be encoded as day-of-the-week, and year.</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">Feature Engineering</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">Maybe PCA could be used on the correlated predictors to make it easier for the models to use them.</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">Feature Engineering</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">Hourly weather records should probably be summarized into daily measurements.</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">Feature Engineering</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">Let’s start with simple linear regression, K-nearest neighbors, and a boosted decision tree.</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">Model Fitting</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">How many neighbors should be used?</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">Model Tuning</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">Should we run a lot of boosting iterations or just a few?</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">Model Tuning</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">How many neighbors seemed to be optimal for these data?</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">Model Tuning</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">Which models have the lowest root mean squared errors?</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">Model Evaluation</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">Which days were poorly predicted?</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">EDA</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">Variable importance scores indicate that the weather information is not predictive. We’ll drop them from the next set of models.</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">Model Evaluation</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">It seems like we should focus on a lot of boosting iterations for that model.</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">Model Evaluation</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">We need to encode holiday features to improve predictions on (and around) those dates.</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">Feature Engineering</td></tr>
    <tr><td headers="Thoughts" class="gt_row gt_left" style="color: #7F7F7F;">Let’s drop KNN from the model list.</td>
<td headers="Activity" class="gt_row gt_left" style="color: #7F7F7F;">Model Evaluation</td></tr>
  </tbody>
  
  
</table>
</div>
</div>
</div>
<p><br></p>
</section>
<section id="opisz-zasadę-działania-testów-bootstrapowych." class="level2">
<h2 class="anchored" data-anchor-id="opisz-zasadę-działania-testów-bootstrapowych.">3. Opisz zasadę działania testów bootstrapowych.</h2>
<!-- Wyliacznie $p$ dla testu bootstrapowego odbywa się wg następujących kroków: -->
<!-- 1. Wyznaczamy na podstawie próby statystykę interesującą nas w teście (w naszym przypadku średnią $\bar x$). -->
<!-- 2. Następnie przesuwamy wszystkie obserwację o różnicę pomiędzy średnią teoretyczną a $\bar x$, tak aby rozkład miał średnią teoretyczną.  -->
<!-- 3. Losujemy próby bootstrapowe z nowej (przesuniętej) próby. -->
<!-- 4. Na podstawie prób bootstrapowych wyznaczamy rozkład średnich poszczególnych prób. -->
<!-- 5. Na koniec sprawdzamy prawdopodobieństwo (szacując na podstawie rozkładu bootstrapowego) otrzymania wartości większych niż średnia oryginalnej próby. Dla hipotez dwustronnych dodajemy do tego prawdopodobieństwo otrzymania wartości mniejszej niż $- \bar x$. -->
<!-- Chodzi o to, że hipoteza dotyczy równości średnich, więc gdy przeniesiemy wszystko na jedną stronę to hipoteza mówi, że różnica średniej z próby i średniej z danej próbki bootsrapowej jest równa $0$. -->
<!-- <li style="color:#808080">Wyznaczamy na podstawie próby interesującą nas statystkę (np. medianę), możemy narysować rozkłady z podziałem ze względu na daną kategorię, których dotyczy hipoteza</li> -->
<!-- <li style="color:#808080"></li> -->
<!-- <li style="color:#808080"></li> -->
<p><br></p>
</section>
<section id="opisz-zasadę-działania-testów-permutacyjnych." class="level2">
<h2 class="anchored" data-anchor-id="opisz-zasadę-działania-testów-permutacyjnych.">4. Opisz zasadę działania testów permutacyjnych.</h2>
<p><br></p>
</section>
<section id="podaj-podział-miar-dopasowania-modeli-predykcyjnych-oraz-wymień-po-trzy-miary-dedykowane-do-modeli-regresyjnych." class="level2">
<h2 class="anchored" data-anchor-id="podaj-podział-miar-dopasowania-modeli-predykcyjnych-oraz-wymień-po-trzy-miary-dedykowane-do-modeli-regresyjnych.">5. Podaj podział miar dopasowania modeli predykcyjnych oraz wymień po trzy miary dedykowane do modeli regresyjnych.</h2>
<p>Wśród miar dopasowania dla modeli regresyjnych można wyróżnić, te które mierzą zgodność pomiędzy wartościami obserwowanymi a przewidywanymi, wyrażone często pewnego rodzaju korelacjami (lub ich kwadratami), a interpretujemy je w ten sposób, że im wyższe wartości tych współczynników tym bardziej zgodne są predykcje z obserwacjami. Drugą duża grupę miar stanowią błędy (bezwzględne i względne), które mierzą w różny sposób różnice pomiędzy wartościami obserwowanymi i przewidywanymi. Jedne są bardziej odporne wartości odstające inne mniej, a wszystkie interpretujemy tak, że jeśli ich wartość jest mniejsza tym lepiej jest dopasowany model.</p>
<p><strong>Miary dopadowania modeli regresyjnych</strong>:</p>
<p><u>Miary bazujące na <strong>korelacjach</strong>:</u></p>
<ol type="1">
<li><p><u><span class="math inline">\(R^2\)</span></u> <br> Miara stosowana najczęściej do oceny dopasowania modeli liniowych, zdefiniowana jako: <span class="math display">\[R^2 = \frac{\sum_i(y_i - \hat y_i)^2}{\sum_i(y_i - \bar y)^2}\]</span> gdzie <br> <span class="math inline">\(\hat y_i\)</span> jest <span class="math inline">\(i\)</span>-tą wartością przewidywaną na podstawie modelu, <br> <span class="math inline">\(\bar y\)</span> jest średnią zmiennej wynikowej, <br> <span class="math inline">\(y_i\)</span> jest <span class="math inline">\(i\)</span>-tą wartością obserwowaną. <br> <br> Wśród wad tak zdefiniowanej miary należy wymienić przede wszystkim fakt, iż dołączając do modelu zmienne, których zdolność predykcyjna jest nieistotna, to i tak rośnie <span class="math inline">\(R^2\)</span> <br> <br> W przypadku modeli liniowych wprowadzaliśmy korektę eliminującą tą wadę, jednak w przypadku modeli predykcyjnych skorygowana miara <span class="math inline">\(R_{\text{adj}}^2\)</span> nie wystarcza. W sytuacji gdy modele mają bardzo słabą moc predykcyjną, czyli są np. drzewem regresyjnym bez żadnej reguły podziału (sam korzeń), wówczas można otrzymać ujemne wartości obu miar. Zaleca się zatem wprowadzenie miary, która pozbawiona jest tej wady, a jednocześnie ma tą sama interpretację. <br> Definiuję się ją następująco: <span class="math display">\[\tilde R^2 = \left[ Cor \left( Y, \hat Y \right) \right]^2\]</span> Tak zdefiniowana miara zapewnia nam wartości w przedziale <span class="math inline">\((0,1)\)</span>, a klasyczna miara nie. Oczywiście interpretacja jest następująca, że jeśli wartość <span class="math inline">\(\tilde R^2\)</span> jest bliska <span class="math inline">\(1\)</span>, to model jest dobrze dopasowany, a bliskie <span class="math inline">\(0\)</span> oznacza słabe dopasowanie.</p></li>
<li><p><u><span class="math inline">\(CCC\)</span></u> <br>Korelacyjny współczynnik zgodności (ang. <em>Concordance Correlation Coefficient</em>) mierzy zgodność pomiędzy wartościami predykcji i obserwowanymi. Definiujemy go w następujący sposób: <span class="math display">\[CCC = \frac{2\rho\sigma_y\sigma_{\hat{y}}}{\sigma^2_{y}+\sigma^2_{\hat{y}}+(\mu_y-\mu_{\hat{y}})^2}\]</span> gdzie <br><span class="math inline">\(\mu_y,\mu_{\hat{y}}\)</span> oznaczają średnią wartości obserwowanych i przewidywanych, <br><span class="math inline">\(\sigma_{y},\sigma_{\hat{y}}\)</span> stanowią odchylenia standardowe tych wielkości, <br><span class="math inline">\(\rho\)</span> est współczynnikiem korelacji pomiędzy <span class="math inline">\(Y\)</span> i <span class="math inline">\(\hat Y\)</span>.</p></li>
</ol>
<!-- 3. <u>$r$</u> <br>Współczynnik korelacji Pearsona (ang. *Pearson Correlation Coefficient*) mierzy siłę liniowej zależności pomiędzy wartościami predykcji i obserowanymi. Definiujemy go w następujący sposób: $$r_{xy}$$ -->
<p><u>Miary bazujące na <strong>błędach</strong>:</u></p>
<ol type="1">
<li><p><u>RMSE</u> <br> Inną powszechnie stosowaną miarą do oceny dopasowania modeli regresyjnych jest pierwiastek błędu średnio-kwadratowego (ang. <em>Root Mean Square Error</em>), zdefiniowany następująco: <span class="math display">\[\text{RMSE} = \sqrt{\frac{\sum^n_{i=1}(y_i-\hat y_i)^2}{n}}\]</span> gdzie <br> <span class="math inline">\(n\)</span> oznacza liczebność zbioru danych na jakim dokonywana jest ocena dopasowania. <br> Im mniejsza jest wartość błędu RMSE tym lepiej dopasowany jest model. Niestety wadą tej miary jest brak odporności na wartości odstające. Błąd w tym przypadku jest mierzony w tych samych jednostkach co mierzona wielkość wynikowa <span class="math inline">\(Y\)</span>.</p></li>
<li><p><u>MSE</u> <br> Ściśle powiązaną miarą dopasowania modelu z RMSE jest błąd średnio-kwadratowy (ang. <em>Mean Square Error</em>). Oczywiście jest on definiowany jako kwadrat RMSE. Interpretacja jest podobna jak w przypadku RMSE. W tym przypadku błąd jest mierzony w jednostkach do kwadratu i również jak w przypadku RMSE miara ta jest wrażliwa na wartości odstające.</p></li>
<li><p><u>MAE</u> <br> Chcąc uniknąć (choćby w części) wrażliwości na wartości odstające stosuje się miarę średniego absolutnego błędu (ang. <em>Mean Absolut Error</em>). Definiujemy go następująco: <span class="math display">\[\text{MAE} = \frac{\sum^n_{i=1}|y_i-\hat y_i|}{n}\]</span> Ponieważ wartości błędów <span class="math inline">\(y_i-\hat y_i\)</span> nie są podnoszone do kwadratu, to miara ta jest mniej wrażliwa na punkty odstające. Interpretacja jej jest podobna jak MSE i RMSE. <br> Błąd w tym przypadku jest również mierzony w tych samych jednostkach co <span class="math inline">\(Y\)</span>.</p>
<p style="color:#808080">
</p><p>Wymienione miary błędów są nieunormowane (tzn. przyjmują również wartości spoza przedziału <span class="math inline">\((0,1)\)</span>), a dopasowania modeli możemy dokonywać jedynie porównując wynik błędu z wartościami <span class="math inline">\(Y\)</span>, lub też przez porównanie miar dla różnych modeli.</p>
<p></p></li>
</ol>
<p><br></p>
</section>
<section id="podaj-podział-miar-dopasowania-modeli-predykcyjnych-oraz-wymień-po-trzy-miary-dedykowane-do-modeli-klasyfikacyjnych." class="level2">
<h2 class="anchored" data-anchor-id="podaj-podział-miar-dopasowania-modeli-predykcyjnych-oraz-wymień-po-trzy-miary-dedykowane-do-modeli-klasyfikacyjnych.">6. Podaj podział miar dopasowania modeli predykcyjnych oraz wymień po trzy miary dedykowane do modeli klasyfikacyjnych.</h2>
<p>W modelach klasyfikacyjnych miary dopasowania można podzielić na te, które dotyczą modeli z binarną zmienną wynikową i ze zmienna wielostanową. Miary można też podzielić na te, które zależą od prawdopodobieństwa poszczególnych stanów i te, które zależą tylko od klasyfikacji wynikowej. <br> Do wyliczenia miar probabilistycznych konieczne jest wyliczenie predykcji z prawdopodobieństwami poszczególnych stanów. <br> Aby przybliżyć miary dopasowania oparte o klasyfikację stanów, konieczne jest wprowadzenie pojęcia macierzy klasyfikacji (ang. <em>confusion matrix</em>). Można je stosować zarówno do klasyfikacji dwustanowej, jak i wielostanowej.</p>
<p>Miary wyliczane na podstawie macierzy klasyfikacji:</p>
<p><img src="obrazki/miary_dopasowania.png" class="img-fluid"></p>
<ol type="1">
<li><p><u>Accuracy</u> - informuje o odsetku poprawnie zaklasyfikowanych obserwacji.</p>
<p style="color:#808080">
</p><p>Miara ta ma jednak poważną wadę, w przypadku modeli dla danych z wyraźną dysproporcją jednej z klas (powiedzmy jedna stanowi 95% wszystkich obserwacji), może się zdarzyć sytuacja, że nawet bezsensowny model, czyli taki, który zawsze wskazuje tą właśnie wartość, będzie miał <em>accuracy</em> na poziomie 95%.</p>
<p></p></li>
<li><p><u>Sensitivity</u> - inaczej nazywana <u>Racall</u> lub <u>True Positive Rate (TPR)</u>, stanowi stosunek <em>true positive</em> do wszystkich przypadków <em>positive</em>.</p></li>
<li><p><u>Specificity</u> (<em>speci TFi TFi</em>) - nazywane również <u>True Negative Rate (TPR)</u>, wyraża się stosunkiem pozycji <em>true negative</em> do wszystkich obserwacji <em>negative</em>.</p></li>
<li><p><u>Balanced Accuracy</u> - liczona jako średnia <em>sensitivity</em> i <em>specificity</em>.</p></li>
</ol>
<p>Należy pamiętać, że aby obserwacje zaklasyfikować do jednej z klas należy przyjąć pewien punkt odcięcia prawdopodobieństwa (<em>threshold</em>), od którego przewidywana wartość będzie przyjmowała stan <span class="math inline">\(,,1''\)</span>. Domyślnie w wielu modelach ten punkt jest ustalony na poziomie <span class="math inline">\(0.5\)</span>. Nie jest on jednak optymalny ze względu na jakość klasyfikacji. Zmieniając ten próg otrzymamy różne wartości powyższych miar. <br> Istnieją kryteria doboru progu odcięcia, np. oparte na wartości <em>Youdena</em>, <em>F1</em>, <em>średniej geometrycznej</em> itp.</p>
<p>Bez względu na przyjęty poziom odcięcia istnieją również miary i wykresy, które pozwalają zilustrować jakość modelu. Należą do nich m.in. <em>ROC</em> i <em>AUC</em> (opisane tutaj <a href="#sec-roc_auc"><span>Section&nbsp;1.8</span></a>)</p>
<p><br></p>
</section>
<section id="podaj-miary-dopasowania-modeli-ze-zmienną-zależną-wieloklasową." class="level2">
<h2 class="anchored" data-anchor-id="podaj-miary-dopasowania-modeli-ze-zmienną-zależną-wieloklasową.">7. Podaj miary dopasowania modeli ze zmienną zależną wieloklasową.</h2>
<p>Miary dedykowane dla modeli binarnych można również wykorzystać do modeli ze zmienną zależną wielostanową. Oczywiście wówczas trzeba użyć pewnego rodzaju uśredniania. Implementacje wieloklasowe wykorzystują mikro, makro i makro-ważone uśrednianie, a niektóre metryki mają swoje własne wyspecjalizowane implementacje wieloklasowe.</p>
<ol type="1">
<li><u>Makro uśrednianie</u> - redukuje wieloklasowe predykcje do wielu zestawów przewidywań binarnych. Oblicza się odpowiednią metrykę dla każdego z przypadków binarnych, a następnie uśrednia wyniki.
<p style="color:#808080">
Jako przykład, rozważmy <em>precision</em>. W przypadku wieloklasowym, jeśli istnieją poziomy A, B, C i D, makro uśrednianie redukuje problem do wielu porównań jeden do jednego. Kolumny truth i estimate są rekodowane tak, że jedynymi dwoma poziomami są A i inne, a następnie precision jest obliczana w oparciu o te rekodowane kolumny, przy czym A jest “wyróżnioną” kolumną. Proces ten jest powtarzany dla pozostałych 3 poziomów, aby uzyskać łącznie 4 wartości precyzji. Wyniki są następnie uśredniane. <br> <br> Formuła dla <span class="math inline">\(k\)</span> klas wynikowych prezentuje się następująco: <span class="math display">\[Pr_\text{macro} = \frac{Pr_1 + Pr_2 + \dots + Pr_k}{k}\]</span> gdzie <br> <span class="math inline">\(Pr_i\)</span> oznacza <em>precision</em> dla <span class="math inline">\(i\)</span>-tej klasy.
</p></li>
<li><u>Makro-ważone uśrednianie</u> - jest co do zasady podobne do metody makro uśredniania, z tą jednak zmianą, że wagi poszczególnych czynników w średniej zależą od liczności tych klas, co sprawia, że miara ta jest bardziej optymalna w przypadku wyraźnych dysproporcji zmiennej wynikowej.
<p style="color:#808080">
Formalnie obliczamy to wg reguły: <span class="math display">\[Pr_\text{weighted-macro} = Pr_1\frac{\#\text{Obs}_1}{n} + Pr_2\frac{\#\text{Obs}_2}{n} + \ldots + Pr_k\frac{\#\text{Obs}_k}{n}\]</span> gdzie <br> <span class="math inline">\(\#\text{Obs}_i\)</span> oznacza liczbę obserwacji w <span class="math inline">\(i\)</span>-tej grupie, <br> <span class="math inline">\(n\)</span> jest liczebnością całego zbioru.
</p></li>
<li><u>Mikro uśrednianie</u> - traktuje cały zestaw danych jako jeden wynik zbiorczy i oblicza jedną metrykę zamiast <span class="math inline">\(k\)</span> metryk, które są uśredniane.
<p style="color:#808080">
Dla precision działa to poprzez obliczenie wszystkich true positive wyników dla każdej klasy i użycie tego jako licznika, a następnie obliczenie wszystkich <em>true positive</em> i <em>false positive</em> wyników dla każdej klasy i użycie tego jako mianownika. <span class="math display">\[Pr_{\text{mirco}} = \frac{TP_1 + TP_2 + \dots + TP_k}{(TP_1 + TP_2 + \dots + TP_k) + (FP_1 + FP_2 + \dots + FP_k)}\]</span> W tym przypadku, zamiast klas o równej wadze, mamy obserwacje z równą wagą. Dzięki temu klasy z największą liczbą obserwacji mają największy wpływ na wynik.
</p></li>
</ol>
<p><br></p>
</section>
<section id="sec-roc_auc" class="level2">
<h2 class="anchored" data-anchor-id="sec-roc_auc">8. Opisz czym jest krzywa ROC i miara AUC.</h2>
<ol type="1">
<li><p><u>ROC (<em>Receiver Operating Characteristic</em>)</u> - krzywa, która przedstawia kompromis pomiędzy sensitivity i specificity dla różnych poziomów odcięcia. Pokazuje ona, ile poprawnych pozytywnych klasyfikacji można uzyskać, gdy dopuszcza się coraz więcej fałszywych pozytywów.</p></li>
<li><p><u>AUC (<em>Area Under ROC Curve</em>)</u> - mierzy pole pod krzywą ROC. Krzywa ROC nie jest pojedynczą liczbą ale całą krzywą. Dostarcza ona szczegółowych informacji o zachowaniu klasyfikatora, ale trudno jest szybko porównać wiele krzywych ROC ze sobą. W szczególności, jeśli ktoś chciałby zastosować jakiś automatyczny mechanizm tuningowania hiperparametrów, maszyna potrzebowałaby wymiernego wyniku zamiast wykresu, który wymaga wizualnej inspekcji. AUC jest jednym ze sposobów podsumowania krzywej ROC w jedną liczbę, tak aby można było ją łatwo i automatycznie porównać.</p></li>
</ol>
<p><img src="obrazki/roc1.png" class="img-fluid"></p>
<p><br></p>
</section>
<section id="opisz-do-czego-jest-stosowany-podział-na-próbę-uczącą-i-testową-oraz-opisz-jak-można-przeprowadzić-podział-na-co-wpływa-proporcja-podziału-jak-ją-można-ustalić." class="level2">
<h2 class="anchored" data-anchor-id="opisz-do-czego-jest-stosowany-podział-na-próbę-uczącą-i-testową-oraz-opisz-jak-można-przeprowadzić-podział-na-co-wpływa-proporcja-podziału-jak-ją-można-ustalić.">9. Opisz do czego jest stosowany podział na próbę uczącą i testową oraz opisz jak można przeprowadzić podział, na co wpływa proporcja podziału, jak ją można ustalić.</h2>
Podstawowym podejściem w empirycznej walidacji modelu jest podział istniejącej puli danych na dwa odrębne zbiory - treningowy i testowy. Zbiór treningowy stanowi zazwyczaj większość danych. Dane te służą dla budowy modelu, poszukiwania optymalnych parametrów modelu, czy selekcji cech istotnych z punktu widzenia predykcji. Pozostała część danych stanowi zbiór testowy. Jest on trzymany aż do momentu, gdy jeden lub dwa modele zostaną wybrane jako metody najlepiej opisujące badane zjawisko. Zestaw testowy jest wtedy używany jako ostateczny arbiter do określenia dopasowania modelu. Krytyczne jest, aby użyć zbiór testowy tylko raz; w przeciwnym razie staje się on częścią procesu modelowania.
<p style="color:#808080">
Proporcje w jakich należy podzielić dane nie są wyraźnie sprecyzowane. Choć istnieją prace, jak np. Joseph (2022), które wskazują konkretne reguły podziału zbioru danych na uczący i testowy dla modeli regresyjnych. W przypadku wspomnianej metody próba testowa powinna stanowić <span class="math inline">\(\frac{1}{\sqrt p + 1}\)</span> zbioru danych, gdzie <span class="math inline">\(p\)</span> oznacza liczbę predyktorów modelu.
</p>
W podziale zbioru danych na uczący i testowy, ważny jest jeszcze jeden aspekt. W jaki sposób podziału dokonujemy. Najpowszechniej stosowany jest podział losowy (losowanie proste). Metoda ta ma jednak istotną wadę. Próbkowanie losowe działa poprawnie na zbiorach danych zbalansowanych klasowo, czyli takich, w których liczba próbek w każdej kategorii jest mniej więcej taka sama. W przypadku zbiorów danych niezbalansowanych klasowo, taka metoda podziału danych może tworzyć obciążenie modelu.
<p style="color:#808080">
Na przykład, jeśli zbiór danych zawiera 100 obrazów, z których 80 należy do kategorii “pies” i 20 należy do kategorii “kot”, a losowe próbkowanie jest stosowane do podziału danych na zbiory uczący i testowy w stosunku 80%-20% (odpowiednio), może się tak zdarzyć, że zbiór treningowy składa się tylko z obrazów psów, podczas gdy zbiór testowy składa się tylko z obrazów kotów. Nawet jeśli nie zdarzy się tak ekstremalny przypadek, to nierównowaga rozkładów w obu zbiorach może być wyraźna.
</p><p>
Losowanie warstwowe zastosowane do podziału zbioru danych łagodzi problem próbkowania losowego w zbiorach danych z niezrównoważonym rozkładem klas. W tym przypadku, rozkład klas w każdym z zestawów treningowych i testowych jest zachowany.
</p><p style="color:#808080">
Załóżmy, że zbiór danych składa się z 100 obrazów, z których 60 to obrazy psów, a 40 to obrazy kotów. W takim przypadku próbkowanie warstwowe zapewnia, że 60% obrazów należy do kategorii “pies”, a 40% do kategorii “kot” w zbiorach uczącym i testowym. Oznacza to, że jeśli pożądany jest podział w proporcji 80%-20%, z 80 obrazów w zbiorze treningowym, 48 obrazów (60%) będzie należało do psów, a pozostałe 32 (40%) do kotów.
</p>
<p style="color:#808080">
Jeszcze jedna uwaga na temat losowego podziału zbioru na uczący i testowy. W jednej sytuacji podział losowy i warstwowy nie są najlepszym rozwiązaniem - chodzi o szeregi czasowe lub dane zawierające znaczący czynnik zmienności w czasie. Wówczas stosuje się podział zbioru za pomocą funkcji initial_time_split, która parametrem prop określa jaka proporcja obserwacji z początku zbioru danych będzie wybrana do zbioru uczącego
</p>
<p>Mierzenie wydajności poprzez przewidywanie na podstawie zbioru treningowego prowadziło do wyników, które były zbyt optymistyczne (nierealistycznie). Prowadziło to do modeli, które były nadmiernie dopasowane. Aby ograniczyć ten problem, wybierano ze zbioru uczącego niewielki zbiór walidacyjny i użyto go do pomiaru wydajności podczas trenowania sieci. Gdy poziom błędu na zbiorze walidacyjnym zaczynał rosnąć, trening był wstrzymywany. Innymi słowy, zbiór walidacyjny był środkiem do uzyskania przybliżonego poczucia, jak dobrze model działał przed zbiorem testowym.</p>
<p><br></p>
</section>
<section id="na-czym-polega-ekstrakcja-cech-podaj-przykłady-dwóch-technik-z-tego-zakresu." class="level2">
<h2 class="anchored" data-anchor-id="na-czym-polega-ekstrakcja-cech-podaj-przykłady-dwóch-technik-z-tego-zakresu.">10. Na czym polega ekstrakcja cech? Podaj przykłady dwóch technik z tego zakresu.</h2>
<p>Ekstracja cech jest jedną z metod reprezentowania wielu cech jednocześnie.</p>
<p>Większość technik z tych technik tworzy nowe cechy z predyktorów, które wychwytują informacje w szerszym zestawie jako całości. <br> Na przykład, analiza składowych głównych (PCA) próbuje wyodrębnić jak najwięcej oryginalnej informacji w zestawie predyktorów przy użyciu mniejszej liczby cech. PCA jest liniową metodą ekstrakcji, co oznacza, że każda nowa cecha jest liniową kombinacją oryginalnych predyktorów. Jednym z ciekawych aspektów PCA jest to, że każda z nowych cech, zwanych głównymi składowymi, jest nieskorelowana z innymi. Z tego powodu PCA może być bardzo skuteczne w redukcji korelacji pomiędzy predyktorami. PCA zakłada, że wszystkie predyktory są w tej samej skali, przez co stosowanie jej powinno poprzedzać się normalizacją numerycznych predyktorów. <br> Wśród innych metod ekstrakcji można wymienić analizę składowych niezależnych (ICA), faktoryzację macierzy nieujemnej (NNMF), skalowanie wielowymiarowe (MDS), jednolitą aproksymacja i projekcja (UMAP).</p>
<p><br></p>
</section>
<section id="czym-jest-walidacja-krzyżowa-i-walidacja-krzyżowa-z-powtórzeniami" class="level2">
<h2 class="anchored" data-anchor-id="czym-jest-walidacja-krzyżowa-i-walidacja-krzyżowa-z-powtórzeniami">11. Czym jest walidacja krzyżowa i walidacja krzyżowa z powtórzeniami?</h2>
<p>Walidacja krzyżowa (ang. <em>cross-validation</em>) jest dobrze ugruntowaną metodą próbkowania. Chociaż istnieje wiele odmian, najbardziej powszechną metodą walidacji krzyżowej jest <span class="math inline">\(V\)</span>-krotna walidacja krzyżowa. Dane są losowo dzielone na <span class="math inline">\(V\)</span> zbiorów o mniej więcej równej wielkości (zwanych krotkami lub foldami).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="obrazki/walidacja1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption"><span class="math inline">\(V=3\)</span> dla zbioru danych składającego się z 30 punktów zbioru treningowego z losowym przydziałem foldów. Liczba wewnątrz symboli to numer próbki. Kolory symboli reprezentują ich losowo przypisane foldy.</figcaption>
</figure>
</div>
<p><img src="obrazki/walidacja2.png" class="img-fluid"></p>
<p>Dla każdej iteracji jeden fold jest zatrzymywany do oceny modelu, a pozostałe foldy są używane do uczenia modelu. Proces ten jest kontynuowany dla każdego folda, tak że trzy modele dają trzy zestawy statystyk dopasowania. <br> Gdy <span class="math inline">\(V = 3\)</span> zbiory analiz stanowią 2/3 zbioru treningowego, a każdy zbiór oceny stanowi odrębną 1/3. Końcowa estymacja resamplingu wydajności uśrednia każdą z <span class="math inline">\(V\)</span> replik.</p>
<p style="color:#808080">
Użycie <span class="math inline">\(V=3\)</span> jest dobrym wyborem do zilustrowania walidacji krzyżowej, ale jest to zły wybór w praktyce, ponieważ jest zbyt mało foldów, aby wygenerować wiarygodne szacunki. W praktyce wartości <span class="math inline">\(V\)</span> to najczęściej 5 lub 10; raczej preferujemy 10-krotną walidację krzyżową jako domyślną, ponieważ jest ona wystarczająco duża, aby uzyskać dobre wyniki w większości sytuacji.
</p>
<p>Jakie są skutki zmiany <span class="math inline">\(V\)</span>? Większe wartości powodują, że szacunki z próbkowania mają mały błąd/obciążenie, ale znaczną wariancję. Mniejsze wartości <span class="math inline">\(V\)</span> mają duży błąd, ale niską wariancję. Preferujemy 10-krotne, ponieważ szum jest zmniejszony przez replikacje, ale obciążenie już nie.</p>
<hr>
<p>Najważniejszą odmianą walidacji krzyżowej jest <span class="math inline">\(V\)</span>-krotna walidacja krzyżowa z powtórzeniami. W zależności od rozmiaru danych i innych cech, ocena modelu uzyskana w wyniku <span class="math inline">\(V\)</span>-krotnej walidacji krzyżowej może być nadmiernie zaszumiona. Podobnie jak w przypadku wielu problemów statystycznych, jednym ze sposobów zmniejszenia szumu jest zebranie większej ilości danych. W przypadku walidacji krzyżowej oznacza to uśrednienie więcej niż <span class="math inline">\(V\)</span> statystyk.</p>
<p>Aby stworzyć <span class="math inline">\(R\)</span> powtórzeń <span class="math inline">\(V\)</span>-ktornej walidacji krzyżowej, ten sam proces generowania foldów jest wykonywany <span class="math inline">\(R\)</span> razy, aby wygenerować <span class="math inline">\(R\)</span> zbiorów złożonych z <span class="math inline">\(V\)</span> podzbiorów. Zamiast uśredniania <span class="math inline">\(V\)</span> statystyk, <span class="math inline">\(V \times R\)</span> wartości daje ostateczną estymację resamplingu.</p>
<p style="color:#808080">
Generalnie zwiększanie liczby replikacji nie ma dużego wpływu na błąd standardowy estymacji, chyba że bazowa wartość <span class="math inline">\(\sigma\)</span> jest duża, wówczas faktycznie warto zwiększać liczbę replikacji.
</p>
<p><br></p>
</section>
<section id="czym-jest-metoda-leave-one-out" class="level2">
<h2 class="anchored" data-anchor-id="czym-jest-metoda-leave-one-out">12. Czym jest metoda Leave-One-Out?</h2>
<p>Jedną z odmian walidacji krzyżowej jest walidacja krzyżowa typu Leave-One-Out (LOO). Jeśli mamy <span class="math inline">\(n\)</span> próbek zbioru treningowego, <span class="math inline">\(n\)</span> modeli jest dopasowywanych przy użyciu <span class="math inline">\(n-1\)</span> wierszy zbioru treningowego. Każdy model przewiduje pojedynczy wykluczony punkt danych. Na koniec próbkowania <span class="math inline">\(n\)</span> prognoz jest łączonych w celu uzyskania pojedynczej statystyki dopasowania. Metody <em>LOO</em> są gorsze w porównaniu z prawie każdą inną metodą oceny dopasowania. <br>Dla wszystkich oprócz patologicznie małych próbek, <em>LOO</em> jest obliczeniowo złożony i może nie mieć dobrych właściwości statystycznych.</p>
<p><br></p>
</section>
<section id="czym-jest-walidacja-metodą-monte-carlo" class="level2">
<h2 class="anchored" data-anchor-id="czym-jest-walidacja-metodą-monte-carlo">13. Czym jest walidacja metodą Monte-Carlo?</h2>
<p>Innym wariantem <span class="math inline">\(V\)</span>-krotnej walidacji krzyżowej jest walidacja krzyżowa Monte-Carlo (ang. <em>Monte-Carlo Cross-Validation</em> - <em>MCCV</em>) Podobnie jak w sprawdzianie krzyżowym, przydziela ona ustaloną część danych do zbiorów oceny. Różnica między <em>MCCV</em> a zwykłą walidacją krzyżową polega na tym, że w przypadku <em>MCCV</em> ta część danych jest za każdym razem wybierana losowo. Przez to powstają zestawy oceny, które nie wykluczają się wzajemnie.</p>
<p><br></p>
</section>
<section id="jak-stosujemy-bootstraping-do-walidacji-modeli" class="level2">
<h2 class="anchored" data-anchor-id="jak-stosujemy-bootstraping-do-walidacji-modeli">14. Jak stosujemy bootstraping do walidacji modeli?</h2>
<p style="color:#808080">
Bootstrap został pierwotnie wynaleziony jako metoda aproksymacji próbkowego rozkładu statystyki, którego własności teoretyczne są nieznane. Wykorzystanie jej do szacowania dopasowania modelu jest wtórnym zastosowaniem tej metody.
</p>
<p>Próbka bootstrapowa zbioru treningowego to próbka, która ma ten sam rozmiar co zbiór treningowy, ale jest losowana ze zwracaniem. Oznacza to, że niektóre obserwacje zbioru treningowego są wielokrotnie wybierane do zbioru analitycznego. Każdy punkt danych ma 63,2% szans na włączenie do zbioru uczącego przynajmniej raz. Zestaw oceny zawiera wszystkie próbki zestawu treningowego, które nie zostały wybrane do zestawu analitycznego (średnio 36,8% zestawu treningowego). Podczas <em>bootstrappingu</em> zestaw oceny jest często nazywany próbką poza workiem (ang. <em>Out-Of-Bag</em>).</p>
<p><img src="obrazki/bootstrap1.png" class="img-fluid" alt="Schemat trzech próbek bootstrapowych dla zbioru treningowego składającego się z 30 próbek."> Próbki bootstrapowe (w przeciwieństwie do walidacji krzyżowej) dają oszacowania dopasowania, które mają bardzo niską wariancję , ale są pesymistyczne w ocenie obciążenia. Oznacza to, że jeśli prawdziwa dokładność modelu wynosi 90%, bootstrap będzie miał tendencję do oszacowania wartości mniejszej niż 90%. Wielkość błędu systematycznego nie może być określona empirycznie z wystarczającą dokładnością. Dodatkowo, wielkość błędu systematycznego zmienia się w zależności od skali dopasowania. Na przykład obciążenie będzie prawdopodobnie inne, gdy dokładność wynosi 90% w porównaniu z 70%.</p>
<p style="color:#808080">
<em>Bootstrap</em> jest również wykorzystywany wewnątrz wielu modeli. Na przykład, wspomniany wcześniej model lasu losowego zawierał 1000 indywidualnych drzew decyzyjnych. Każde drzewo było produktem innej próbki bootstrapowej zbioru treningowego.
</p>
<p><br></p>
</section>
<section id="czym-jest-i-do-czego-stosujemy-próbkowanie-kroczące" class="level2">
<h2 class="anchored" data-anchor-id="czym-jest-i-do-czego-stosujemy-próbkowanie-kroczące">15. Czym jest i do czego stosujemy próbkowanie kroczące?</h2>
<p>Gdy dane mają istotny składnik czasowy (jak np. szeregi czasowe), metoda próbkowania powinna pozwolić na oszacowanie sezonowych i okresowych trendów w szeregach czasowych. Technika, która losowo próbkuje wartości ze zbioru treningowego, nie pozwoli na oszacowanie tych wzorców.</p>
<p>Kroczące próbkowanie źródła (ang. rolling forecast origin resampling) jest metodą, która emuluje sposób, w jaki dane szeregów czasowych są często partycjonowane w praktyce, estymując parametry modelu na danych historycznych i oceniając go z najnowszymi danymi. Dla tego typu resamplingu określa się rozmiar zbiorów analiz i ocen. Pierwsza iteracja resamplingu wykorzystuje te rozmiary, zaczynając od początku serii. Druga iteracja wykorzystuje te same rozmiary danych, ale przesuwa się o ustaloną liczbę próbek.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="obrazki/krocz1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Zbiór treningowy składający się z piętnastu próbek został ponownie próbkowany z rozmiarem zbioru analizy wynoszącym 8 próbek i zbioru oceny wynoszącym 3. W drugiej iteracji odrzucono pierwszą próbkę zbioru uczącego, a oba zbiory danych przesunięto do przodu o jeden. W tej konfiguracji uzyskuje się pięć próbek.</figcaption>
</figure>
</div>
<p>Istnieją dwie różne konfiguracje tej metody:</p>
<ul>
<li><p>Zestaw analiz może narastać (w przeciwieństwie do utrzymywania tego samego rozmiaru). Po pierwszym początkowym zestawie analitycznym nowe próbki mogą narastać bez odrzucania wcześniejszych danych. W rezultacie oznacza to, że po nauczeniu i ocenie dopasowania modelu na <em>Resample 1</em>, model jest uczony na zbiorze rozszerzonym o obserwację 9, czyli na danych od 1 do 9. Następnie oceniany na obserwacjach od 10 do 12, itd.</p></li>
<li><p>Próbki nie muszą być zwiększane o jeden. Na przykład, w przypadku dużych zestawów danych, blok przyrostowy może wynosić tydzień lub miesiąc zamiast dnia.</p></li>
</ul>
<p><br></p>
</section>
<section id="na-czym-polega-optymalizacja-modeli-predykcyjnych" class="level2">
<h2 class="anchored" data-anchor-id="na-czym-polega-optymalizacja-modeli-predykcyjnych">16. Na czym polega optymalizacja modeli predykcyjnych?</h2>
<p>Proces w którym odbywa się poszukiwanie optymalnych parametrów modelu nazywamy optymalizacją modelu (ang. tuning). Definicję tę można nawet rozszerzyć, jeśli pomyślimy o dostosowaniu takich parametrów jak szybkość uczenia sieci neuronowej, rodzaj metody gradientowej, czy liczba iteracji/epok w procesie uczenia. Co więcej również w procesie przygotowania danych do modelowania, występują parametry, których wartość należy optymalizować. Przykładowo liczba składowych głównych w PCA jest hiperparametrem, którego wartość należy dostrajać. Nawet w kontekście wspomnianych klasycznych modeli jak np. regresja możemy optymalizować model pod kątem wyboru funkcji łączącej. Jak zatem przeprowadzić optymalizację modelu, skoro tak wiele różnych parametrów może wpłynąć na ostateczną jego postać? To zależy od tego co chcemy optymalizować. Przykładowo jeśli obiektem naszych zainteresowań jest wybór najlepszej funkcji łączącej, to powinniśmy użyć do tego funkcji celu jako miary oceniającej rozwiązania. Friedman pokazał, że optymalna liczba drzew będzie inna jeśli w procesie optymalizacji użyjemy dwóch różnych kryteriów oceny modelu - funkcji wiarygodności i dokładności (<em>accuracy</em>).</p>
<p><br></p>
</section>
<section id="przedstaw-zasadę-działania-dwóch-sposobów-podejścia-do-tuningu-modeli." class="level2">
<h2 class="anchored" data-anchor-id="przedstaw-zasadę-działania-dwóch-sposobów-podejścia-do-tuningu-modeli.">17. Przedstaw zasadę działania dwóch sposobów podejścia do tuningu modeli.</h2>
<p>Istnieją dwa sposoby realizacji tuningu modeli:</p>
<ul>
<li><p><u>Przeszukiwanie siatki</u> - gdy wstępnie określamy zestaw wartości parametrów do oceny. Głównymi problemami związanymi z przeszukiwaniem siatki są sposób wykonania siatki i liczba kombinacji parametrów do oceny. Przeszukiwanie siatki jest często oceniane jako nieefektywne, ponieważ liczba punktów siatki wymaganych do pokrycia przestrzeni parametrów może stać się niemożliwa do opanowania. Z jednej strony jest w tym trochę prawdy, ale jest to najbardziej uzasadniona metoda, gdy proces nie jest zoptymalizowany.</p></li>
<li><p><u>przeszukiwanie iteracyjne</u> lub <u>sekwencyjne</u> - gdy sekwencyjnie odkrywamy nowe kombinacje parametrów na podstawie poprzednich wyników. W niektórych przypadkach do rozpoczęcia procesu optymalizacji wymagany jest wstępny zestaw wyników dla jednej lub więcej kombinacji parametrów.</p></li>
</ul>
<p style="color:#808080">
</p><p>Można też stosować rozwiązania hybrydowe, gdzie metoda siatki jest stosowana do wstępnego oszacowania parametrów modelu, a następnie metodami iteracyjnymi korygowane są wspomniane parametry.</p>
W procesie dostrajania modelu, możemy szacować hiperparametry główne oraz specyficzne dla danego silnika metody.
<p></p>
<p><img src="obrazki/tuning1.png" class="img-fluid"></p>
<p><br></p>
</section>
<section id="opisz-przeszukiwanie-z-wykorzystaniem-siatki-regularnej-i-nieregularnej." class="level2">
<h2 class="anchored" data-anchor-id="opisz-przeszukiwanie-z-wykorzystaniem-siatki-regularnej-i-nieregularnej.">18. Opisz przeszukiwanie z wykorzystaniem siatki regularnej i nieregularnej.</h2>
<p>W metodach przeszukiwania siatki (ang. <em>grid search</em>) możliwe wartości parametrów określa się <em>a priori</em>. <br> Istnieją dwa główne rodzaje siatek:</p>
<ol type="1">
<li><p><u>Siatki regularne</u> łączą każdy parametr (z odpowiadającym mu zbiorem możliwych wartości) czynnikowo, tj. poprzez wykorzystanie wszystkich kombinacji zbiorów. <br> Regularne siatki są kombinacjami oddzielnych zestawów wartości parametrów, gdzi użytkownik najpierw tworzy odrębny zestaw wartości dla każdego parametru. Liczba możliwych wartości nie musi być taka sama dla każdego parametru.</p></li>
<li><p><u>Siatka nieregularne</u> to taka, w której kombinacje parametrów nie są tworzone regularnie. <br> Istnieje kilka możliwości tworzenia nieregularnych siatek. Pierwszą z nich jest użycie losowego próbkowania w całym zakresie parametrów. Jeśli parametr ma powiązane przekształcenie, liczby losowe są generowane w przekształconej skali.</p>
<p style="color:#808080">
</p><p>Problem z siatkami losowymi polega na tym, że przy małych i średnich siatkach wartości losowe mogą powodować nakładanie się kombinacji parametrów. Ponadto siatka losowa musi pokryć całą przestrzeń parametrów, a prawdopodobieństwo dobrego pokrycia rośnie wraz z liczbą wartości siatki.</p>
<p></p></li>
</ol>
<p><br></p>
</section>
<section id="opisz-zasadę-wykorzystania-wielu-rdzeni-procesora-w-optymalizacji-modelu." class="level2">
<h2 class="anchored" data-anchor-id="opisz-zasadę-wykorzystania-wielu-rdzeni-procesora-w-optymalizacji-modelu.">19. Opisz zasadę wykorzystania wielu rdzeni procesora w optymalizacji modelu.</h2>
<p>Chcąc przyspieszyć procedurę tuningu, musimy stosować paralelizację procedury dostrajania. W pakiecie <code>tune</code> możliwe jest zastosowanie paralelizacji na dwa sposoby. Podczas dostrajania modeli poprzez wyszukiwanie w siatce, istnieją dwie odrębne pętle: jedna nad foldami (zewnętrzna pętla) i druga nad unikalnymi kombinacjami parametrów (wewnętrzna pętla).</p>
<p>Domyślnie pakiet <code>tune</code> paralelizuje tylko nad próbkami (pętla zewnętrzna). Jest to optymalny scenariusz, gdy metody wstępnego przetwarzania (<em>preprocessing</em>) są kosztowne oblczeniowo. Istnieją jednak dwa potencjalne minusy tego podejścia:</p>
<ul>
<li><p>Ogranicza osiągalne przyspieszenia, gdy preprocessing nie jest wymagający obliczeniowo.</p></li>
<li><p>Liczba równoległych rdzeni jest ograniczona przez liczbę foldów. Na przykład przy 10-krotnej walidacji krzyżowej można użyć tylko 10 równoległych rdzeni, nawet jeśli komputer ma więcej.</p></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="obrazki/preproc1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Przydzielenie zadań procesorom robotniczym ilustrujące działanie przetwarzania równoległego. W tym konkretnym przypadku, w którym istnieje 7 wartości parametrów dostrajania modelu, przy 5-krotnej walidacji krzyżowej.</figcaption>
</figure>
</div>
<p style="color:#808080">
Każdy fold jest przypisany do własnego procesu roboczego, a ponieważ dostrajane są tylko parametry modelu, przetwarzanie wstępne jest przeprowadzane raz na fold/rdzeń. Jeśli użyto by mniej niż pięciu rdzeni, niektóre rdzenie otrzymaliby do przeliczenia kilka foldów.
</p>
<p>Zamiast równoległego przetwarzania tylko nad zewnętrzną pętlą, alternatywny schemat łączy pętle nad foldami i modelami w jedną pętlę. W tym przypadku paralelizacja występuje teraz nad pojedynczą pętlą. Na przykład, jeśli używamy 5-krotnej walidacji krzyżowej z <span class="math inline">\(M\)</span> wartościami parametrów dostrajania, pętla jest wykonywana przez <span class="math inline">\(5 \times M\)</span> iteracji. Zwiększa to liczbę potencjalnych rdzeni, które można wykorzystać. Jednak praca związana ze wstępnym przetwarzaniem danych jest powtarzana wielokrotnie. Jeśli te kroki są wymagające obliczeniowo, to podejście to będzie nieefektywne.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="obrazki/tuning2.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Delegowanie zadań do robotników w tym schemacie; użyty jest ten sam przykład, ale z 10 rdzeniami.</figcaption>
</figure>
</div>
<p>Tutaj każdy proces roboczy obsługuje wiele foldów, a przetwarzanie wstępne jest niepotrzebnie powtarzane. Na przykład, dla pierwszego foldu, preprocessing został wykonany siedem razy zamiast raz. Dla tego schematu argumentem funkcji sterującej jest <code>parallel_over = "everything"</code>.</p>
<p><br></p>
</section>
<section id="czym-jest-metoda-wyścigów" class="level2">
<h2 class="anchored" data-anchor-id="czym-jest-metoda-wyścigów">20. Czym jest metoda wyścigów?</h2>
<p><br></p>
</section>
<section id="czym-jest-przeszukiwanie-iteracyjne" class="level2">
<h2 class="anchored" data-anchor-id="czym-jest-przeszukiwanie-iteracyjne">21. Czym jest przeszukiwanie iteracyjne?</h2>
<p>Wyszukiwanie oparte o siatkę przyjmuje wstępnie zdefiniowany zestaw wartości kandydujących, ocenia je, a następnie wybiera najlepsze ustawienia. Iteracyjne metody wyszukiwania realizują inną strategię. <u>Podczas procesu wyszukiwania przewidują one, które wartości należy przetestować w następnej kolejności</u>. Przykładami takiego przeszukiwania są:</p>
<ul>
<li><p>Optymalizacja bayesowska (<a href="#sec-bayes"><span>Section&nbsp;1.22</span></a>)</p></li>
<li><p>Symulowane wyżarzanie (<a href="#sec-annealing"><span>Section&nbsp;1.25</span></a>)</p></li>
</ul>
<p><br></p>
</section>
<section id="sec-bayes" class="level2">
<h2 class="anchored" data-anchor-id="sec-bayes">22. Opisz optymalizację bayesowską.</h2>
<p>Techniki optymalizacji bayesowskiej analizują bieżące wyniki próbkowania i tworzą model predykcyjny, aby zasugerować wartości parametrów dostrajania, które nie zostały jeszcze ocenione. Sugerowana kombinacja parametrów jest następnie ponownie próbkowana. Wyniki te są następnie wykorzystywane w innym modelu predykcyjnym, który rekomenduje więcej wartości kandydatów do testowania, i tak dalej. Proces ten przebiega przez ustaloną liczbę iteracji lub do momentu, gdy nie pojawią się dalsze poprawy.</p>
<p style="color:#808080">
Podczas korzystania z optymalizacji bayesowskiej, podstawowe problemy to sposób tworzenia modelu i wybór parametrów rekomendowanych przez ten model. Najpierw rozważmy technikę najczęściej stosowaną w optymalizacji bayesowskiej, czyli model procesu gaussowskiego.
</p>
<p><br></p>
</section>
<section id="czym-są-procesy-gaussowskie" class="level2">
<h2 class="anchored" data-anchor-id="czym-są-procesy-gaussowskie">23. Czym są procesy gaussowskie?</h2>
<!-- <p style="color:#05E00C"> -->
<!-- Ważną zaletą tego modelu jest to, że ponieważ określony jest pełny model prawdopodobieństwa, przewidywania dla nowych wejść mogą odzwierciedlać cały rozkład wyniku. Innymi słowy, nowe statystyki wydajności mogą być przewidywane zarówno pod względem średniej jak i wariancji. -->
<!-- </p> -->
<!-- Zaczyna od wykresu. Przez 4 punkty można wiele krzywych przeprowadzić. Narysować więcej tych krzywych że różne mogą być. W każdym przekroju pomiędzy punktami można narysować Gaussa. Mniejsze prawdopodobieństwo że pójdzie skrajną ścieżką. Wektor średnich i wektor macierzy kowariancji potrzebne do GP. Przez co mają przechodzić i jakie mają rozrzuty. -->
<p style="color:#808080">
Modele procesu gaussowskiego (GP), to techniki statystyczne, które mają swoją historię w statystyce przestrzennej.Mogą być wyprowadzone na wiele sposobów, w tym jako model Bayesowski.
</p>
<p>Matematycznie, GP jest zbiorem zmiennych losowych, których wspólny rozkład prawdopodobieństwa jest wielowymiarowy normalny.</p>
<p>Modele procesów gaussowskich są określone przez ich funkcje średniej i kowariancji, choć to ta ostatnia ma większy wpływ na charakter modelu GP. Funkcja kowariancji jest często parametryzowana w kategoriach wartości wejściowych (oznaczanych jako <span class="math inline">\(x\)</span>).</p>
<p>Przykładowo, powszechnie stosowaną funkcją kowariancji jest funkcja wykładnicza kwadratowa: <span class="math display">\[\operatorname{cov}(\boldsymbol{x}_i, \boldsymbol{x}_j) = \exp\left(-\frac{1}{2}|\boldsymbol{x}_i - \boldsymbol{x}_j|^2\right) + \sigma^2_{ij}\]</span> gdzie <br> <span class="math inline">\(\sigma_{i,j}^2\)</span> jest wariancją błędu modelu równą zero jeśli <span class="math inline">\(i=j\)</span>. <br> Możemy to interpretować jako, że wraz ze wzrostem odległości pomiędzy dwoma kombinacjami parametrów, kowariancja pomiędzy metrykami wydajności rośnie wykładniczo. Z równania wynika również, że zmienność metryki wynikowej (Estimated <span class="math inline">\(R^2\)</span>) jest minimalizowana w punktach, które już zostały zaobserwowane (tzn. gdy <span class="math inline">\(|x_i - x_j|^2\)</span> wynosi 0). Charakter tej funkcji kowariancji pozwala procesowi gaussowskiemu reprezentować wysoce nieliniowe zależności między wydajnością modelu a dostrajaniem parametrów, nawet jeśli istnieje tylko niewielka ilość danych.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="obrazki/GP1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">W każdym przekroju pomiędzy punktami można narysować Gaussa, co ilustruje mniejsze prawdopodobieństwo że wykres pójdzie skrajną ścieżką.</figcaption>
</figure>
</div>
<p>Ważną zaletą tego modelu jest to, że ponieważ określony jest pełny model prawdopodobieństwa, przewidywania dla nowych wejść mogą odzwierciedlać cały rozkład wyniku. Innymi słowy, nowe statystyki wydajności mogą być przewidywane zarówno pod względem średniej jak i wariancji.</p>
<p><br></p>
</section>
<section id="co-to-jest-funkcja-akwizycji" class="level2">
<h2 class="anchored" data-anchor-id="co-to-jest-funkcja-akwizycji">24. Co to jest funkcja akwizycji?</h2>
<p>Klasa funkcji celu, zwanych funkcjami akwizycji, ułatwia kompromis pomiędzy średnią a wariancją. Przypomnijmy, że przewidywana wariancja modeli GP zależy głównie od tego, jak bardzo są one oddalone od istniejących danych. Kompromis pomiędzy przewidywaną średnią i wariancją dla nowych kandydatów jest często postrzegany przez pryzmat eksploracji i eksploatacji:</p>
<ul>
<li><p>Eksploracja - powoduje wybór tych regionów, w których jest mniej obserwowanych modeli kandydujących. W ten sposób nadaje się większą wagę kandydatom o wyższej wariancji i koncentruje się na poszukiwaniu nowych wyników.</p></li>
<li><p>Eksploatacja - zasadniczo opiera się istniejących wynikach, w celu odnalezienia najlepszej wartości średniej.</p></li>
</ul>
<!-- <https://dax44.github.io/ModelsValidation/iterative.html#fig-iter2> <- przykład  -->
<p>Funkcja akwizycji oczekiwanej poprawy wskazuje którego kandydata wybrać (?). Znowu rysuje wykres z wykładu. Mówi o eksploatacji i eksploracji. Funkcja akwizycji wyznaczy kompromis pomiędzy nimi.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="obrazki/GP1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Na wykresie widać dwie przerywane pionowe linie, są to (do lewej) <em>Eksploatacja</em> i <em>Eksploracja</em>.</figcaption>
</figure>
</div>
<p>Jedną z najczęściej stosowanych funkcji akwizycji jest oczekiwana poprawa. Na przykład, rozważmy dwie wartości parametrów kandydujących 0,10 i 0,25 (wskazane przez pionowe linie na powyższym rysunku. Używając dopasowanego modelu GP, ich przewidywane <span class="math inline">\(R^2\)</span> są pokazane na poniższym rysunku wraz z linią odniesienia dla aktualnych najlepszych wyników.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="obrazki/fakwiz.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Porównie rozkładów przewidywania <span class="math inline">\(R^2\)</span> dla wartości przewidywanych przez <em>Eksploatację</em> i <em>Eksplorację</em>.</figcaption>
</figure>
</div>
<p>Rozpatrując tylko średnią <span class="math inline">\(R^2\)</span> lepszym wyborem jest wartość parametru 0,10 Rekomendacja parametru dostrajania dla 0,25 ma gorsze przewidywanie średnie niż aktualny najlepszy kandydat. Jednakże, ponieważ ma wyższą wariancję, ma większy ogólny obszar prawdopodobieństwa powyżej aktualnego najlepszego. W rezultacie ma większą oczekiwaną poprawę:</p>
<div class="cell">
<div class="cell-output-display">

<div id="urkrvhtzgv" style="padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;">
<style>#urkrvhtzgv table {
  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#urkrvhtzgv thead, #urkrvhtzgv tbody, #urkrvhtzgv tfoot, #urkrvhtzgv tr, #urkrvhtzgv td, #urkrvhtzgv th {
  border-style: none;
}

#urkrvhtzgv p {
  margin: 0;
  padding: 0;
}

#urkrvhtzgv .gt_table {
  display: table;
  border-collapse: collapse;
  line-height: normal;
  margin-left: auto;
  margin-right: auto;
  color: #333333;
  font-size: 16px;
  font-weight: normal;
  font-style: normal;
  background-color: #FFFFFF;
  width: auto;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #A8A8A8;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #A8A8A8;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
}

#urkrvhtzgv .gt_caption {
  padding-top: 4px;
  padding-bottom: 4px;
}

#urkrvhtzgv .gt_title {
  color: #333333;
  font-size: 125%;
  font-weight: initial;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-color: #FFFFFF;
  border-bottom-width: 0;
}

#urkrvhtzgv .gt_subtitle {
  color: #333333;
  font-size: 85%;
  font-weight: initial;
  padding-top: 3px;
  padding-bottom: 5px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-color: #FFFFFF;
  border-top-width: 0;
}

#urkrvhtzgv .gt_heading {
  background-color: #FFFFFF;
  text-align: center;
  border-bottom-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#urkrvhtzgv .gt_bottom_border {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#urkrvhtzgv .gt_col_headings {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#urkrvhtzgv .gt_col_heading {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 6px;
  padding-left: 5px;
  padding-right: 5px;
  overflow-x: hidden;
}

#urkrvhtzgv .gt_column_spanner_outer {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 4px;
  padding-right: 4px;
}

#urkrvhtzgv .gt_column_spanner_outer:first-child {
  padding-left: 0;
}

#urkrvhtzgv .gt_column_spanner_outer:last-child {
  padding-right: 0;
}

#urkrvhtzgv .gt_column_spanner {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 5px;
  overflow-x: hidden;
  display: inline-block;
  width: 100%;
}

#urkrvhtzgv .gt_spanner_row {
  border-bottom-style: hidden;
}

#urkrvhtzgv .gt_group_heading {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  text-align: left;
}

#urkrvhtzgv .gt_empty_group_heading {
  padding: 0.5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: middle;
}

#urkrvhtzgv .gt_from_md > :first-child {
  margin-top: 0;
}

#urkrvhtzgv .gt_from_md > :last-child {
  margin-bottom: 0;
}

#urkrvhtzgv .gt_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  margin: 10px;
  border-top-style: solid;
  border-top-width: 1px;
  border-top-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  overflow-x: hidden;
}

#urkrvhtzgv .gt_stub {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
}

#urkrvhtzgv .gt_stub_row_group {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  vertical-align: top;
}

#urkrvhtzgv .gt_row_group_first td {
  border-top-width: 2px;
}

#urkrvhtzgv .gt_row_group_first th {
  border-top-width: 2px;
}

#urkrvhtzgv .gt_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#urkrvhtzgv .gt_first_summary_row {
  border-top-style: solid;
  border-top-color: #D3D3D3;
}

#urkrvhtzgv .gt_first_summary_row.thick {
  border-top-width: 2px;
}

#urkrvhtzgv .gt_last_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#urkrvhtzgv .gt_grand_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#urkrvhtzgv .gt_first_grand_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: double;
  border-top-width: 6px;
  border-top-color: #D3D3D3;
}

#urkrvhtzgv .gt_last_grand_summary_row_top {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: double;
  border-bottom-width: 6px;
  border-bottom-color: #D3D3D3;
}

#urkrvhtzgv .gt_striped {
  background-color: rgba(128, 128, 128, 0.05);
}

#urkrvhtzgv .gt_table_body {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#urkrvhtzgv .gt_footnotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#urkrvhtzgv .gt_footnote {
  margin: 0px;
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#urkrvhtzgv .gt_sourcenotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#urkrvhtzgv .gt_sourcenote {
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#urkrvhtzgv .gt_left {
  text-align: left;
}

#urkrvhtzgv .gt_center {
  text-align: center;
}

#urkrvhtzgv .gt_right {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

#urkrvhtzgv .gt_font_normal {
  font-weight: normal;
}

#urkrvhtzgv .gt_font_bold {
  font-weight: bold;
}

#urkrvhtzgv .gt_font_italic {
  font-style: italic;
}

#urkrvhtzgv .gt_super {
  font-size: 65%;
}

#urkrvhtzgv .gt_footnote_marks {
  font-size: 75%;
  vertical-align: 0.4em;
  position: initial;
}

#urkrvhtzgv .gt_asterisk {
  font-size: 100%;
  vertical-align: 0;
}

#urkrvhtzgv .gt_indent_1 {
  text-indent: 5px;
}

#urkrvhtzgv .gt_indent_2 {
  text-indent: 10px;
}

#urkrvhtzgv .gt_indent_3 {
  text-indent: 15px;
}

#urkrvhtzgv .gt_indent_4 {
  text-indent: 20px;
}

#urkrvhtzgv .gt_indent_5 {
  text-indent: 25px;
}
</style>
<table class="gt_table" data-quarto-disable-processing="false" data-quarto-bootstrap="false">
  <thead>
    
    <tr class="gt_col_headings">
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="Parameter.Value">Parameter.Value</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="Mean">Mean</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="Std.Dev">Std.Dev</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="Expected.Improvment">Expected.Improvment</th>
    </tr>
  </thead>
  <tbody class="gt_table_body">
    <tr><td headers="Parameter.Value" class="gt_row gt_right">0.10</td>
<td headers="Mean" class="gt_row gt_right">0.8679</td>
<td headers="Std.Dev" class="gt_row gt_right">0.0004317</td>
<td headers="Expected.Improvment" class="gt_row gt_right">0.000190</td></tr>
    <tr><td headers="Parameter.Value" class="gt_row gt_right">0.25</td>
<td headers="Mean" class="gt_row gt_right">0.8671</td>
<td headers="Std.Dev" class="gt_row gt_right">0.0039301</td>
<td headers="Expected.Improvment" class="gt_row gt_right">0.001216</td></tr>
  </tbody>
  
  
</table>
</div>
</div>
</div>
<details>
<summary>
Poprawa na całym zakresie
</summary>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="obrazki/fakwiz1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Szacowany profil wydajności wygenerowany przez model procesu gaussowskiego (górny panel) oraz oczekiwana poprawa (dolny panel). Pionowa linia wskazuje punkt maksymalnej poprawy.</figcaption>
</figure>
</div>
<p>Kiedy oczekiwana poprawa jest obliczana w całym zakresie dostrajania parametrów, zalecany punkt do próbkowania jest znacznie bliższy 0,25 niż 0,10.</p>
</details>
<p><br></p>
</section>
<section id="sec-annealing" class="level2">
<h2 class="anchored" data-anchor-id="sec-annealing">25. Opisz zasadę działania metody symulowanego wyżarzania.</h2>
<p>Symulowane wyżarzanie (ang. <em>simulated annealing</em>) jest nieliniową procedurą wyszukiwania zainspirowaną procesem stygnięcia metalu. Jest to metoda globalnego wyszukiwania, która może efektywnie poruszać się po wielu różnych obszarach poszukiwań, w tym po funkcjach nieciągłych. W przeciwieństwie do większości procedur optymalizacji opartych na gradiencie, symulowane wyżarzanie może ponownie ocenić poprzednie rozwiązania.</p>
<p>Proces użycia symulowanego wyżarzania rozpoczyna się od wartości początkowej i rozpoczyna kontrolowany losowy spacer przez przestrzeń parametrów. Każda nowa wartość parametrukandydata jest niewielką perturbacją poprzedniej wartości, która utrzymuje nowy punkt w lokalnym sąsiedztwie.</p>
<p>Punkt kandydujący jest oceniany przy zastosowaniu resamplingu, aby uzyskać odpowiadającą mu wartość wydajności. Jeśli osiąga ona lepsze wyniki niż poprzednie parametry, jest akceptowana jako nowa najlepsza i proces jest kontynuowany. Jeśli wyniki są gorsze niż poprzednia wartość, procedura wyszukiwania może nadal używać tego parametru do określenia dalszych kroków. Zależy to od dwóch czynników. Po pierwsze, prawdopodobieństwo zatrzymania złego kandydata maleje wraz z pogorszeniem się wyników. Innymi słowy, tylko nieco gorszy wynik od obecnie najlepszego ma większą szansę na akceptację niż ten z dużym spadkiem wydajności. Drugim czynnikiem jest liczba iteracji wyszukiwania. Symulowane wyżarzanie próbuje zaakceptować mniej suboptymalnych wartości w miarę postępu wyszukiwania.</p>
<p>Dla złego wyniku określamy prawdopodobieństwo akceptacji i porównujemy je z liczbą wylosowaną z rozkładu jednostajnego. Jeśli liczba ta jest większa od wartości prawdopodobieństwa, wyszukiwanie odrzuca bieżące parametry i następna iteracja tworzy swoją wartość kandydata w sąsiedztwie poprzedniej wartości. W przeciwnym razie następna iteracja tworzy kolejny zestaw parametrów na podstawie bieżących (suboptymalnych) wartości.</p>
<details style="color:#808080">
<summary>
Wzór na prawdopodobieństwo akceptacji złego wyniku
</summary>
<p>Prawdopodobieństwo akceptacji złego wyniku można sformalizować jako:</p>
<p><span class="math display">\[\operatorname{Pr}[\text{accept suboptimal parameters at iteration } i] = \exp(c\times D_i \times i)\]</span></p>
gdzie <br> <span class="math inline">\(i\)</span> jest numerem iteracji,<br><span class="math inline">\(c\)</span> jest stałą określoną przez użytkownika,<br><span class="math inline">\(D_i\)</span> jest procentową różnicą pomiędzy starą i nową wartością (gdzie wartości ujemne oznaczają gorsze wyniki).
</details>
<p>Proces ten trwa przez określoną ilość iteracji, ale może zostać zatrzymany, jeśli w ciągu określonej liczby iteracji nie pojawią się globalnie najlepsze wyniki. Bardzo pomocne może być ustawienie progu restartu. Jeśli wystąpi ciąg niepowodzeń, funkcja ta powraca do ostatnich globalnie najlepszych ustawień parametrów i zaczyna od nowa.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="obrazki/annealing1.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Mapa ciepła prawdopodobieństwa akceptacji symulowanego wyżarzania dla różnych wartości współczynnika. Pokazuje, jak prawdopodobieństwo akceptacji może się zmieniać w zależności od iteracji, wydajności i współczynnika określonego przez użytkownika.</figcaption>
</figure>
</div>
<p><br></p>
</section>
<section id="przedstaw-powody-stosowania-redukcji-wymiarowości." class="level2">
<h2 class="anchored" data-anchor-id="przedstaw-powody-stosowania-redukcji-wymiarowości.">26. Przedstaw powody stosowania redukcji wymiarowości.</h2>
<p style="color:#808080">
Redukcja wymiarowości (ang. dimensionality reduction) jest przekształceniem zbioru danych z przestrzeni wielowymiarowej w przestrzeń niskowymiarową i może być dobrym wyborem, gdy podejrzewamy, że jest “za dużo” zmiennych. Nadmiar zmiennych, zwykle predyktorów, może być problemem, ponieważ trudno jest zrozumieć lub wizualizować dane w wyższych wymiarach.
</p>
<ul>
<li><p>Podejrzewamy, że jest “za dużo” zmiennych. Nadmiar zmiennych, zwykle predyktorów, może być problemem, ponieważ trudno jest zrozumieć lub wizualizować dane w wyższych wymiarach.</p></li>
<li><p>Eksploracja danych jest trudna, gdy istnieją setki tysięcy wymiarów, a redukcja wymiarowości może być pomocą w analizie danych</p></li>
<li><p>Model ma nadmiarową liczbę predyktorów. Np w regresji liniowej liczba predyktorów powinna być mniejsza niż liczba obserwacji użytych do dopasowania modelu.</p></li>
<li><p>Współliniowość, gdzie korelacje między predyktorami mogą negatywnie wpływać na operacje matematyczne używane do oszacowania modelu. Jeśli istnieje bardzo duża liczba predyktorów, jest mało prawdopodobne, że istnieje taka sama liczba rzeczywistych efektów leżących u podstaw. Predyktory mogą mierzyć ten sam ukryty efekt (efekty), a zatem takie predyktory będą wysoko skorelowane.</p></li>
</ul>
<p><br></p>
</section>
<section id="jakie-są-powody-stosowania-podpróbkowania-i-nadpróbkowania-w-modelowaniu-predykcyjnym" class="level2">
<h2 class="anchored" data-anchor-id="jakie-są-powody-stosowania-podpróbkowania-i-nadpróbkowania-w-modelowaniu-predykcyjnym">27. Jakie są powody stosowania podpróbkowania i nadpróbkowania w modelowaniu predykcyjnym?</h2>
<p>Próbkowanie (ang. subsampling) zbioru treningowego, zarówno zaniżanie (ang. undersampling), jak i zawyżanie (ang. oversampling) próbkowania odpowiedniej klasy lub klas, może być pomocne w radzeniu sobie z danymi klasyfikacyjnymi, w których jedna lub więcej klas występuje bardzo rzadko. W takiej sytuacji (bez kompensacji), większość modeli będzie nadmiernie dopasowana do klasy większościowej i wytworzy bardzo dobre statystyki dopasowania dla klasy zawierającej często występujące klasy, podczas gdy klasy mniejszościowe będą miały słabe wyniki.</p>
<p><br></p>
</section>
<section id="jakie-są-korzyści-ze-stosowania-próbkowania-zaniżającego-liczebność-klasy-większościowej" class="level2">
<h2 class="anchored" data-anchor-id="jakie-są-korzyści-ze-stosowania-próbkowania-zaniżającego-liczebność-klasy-większościowej">28. Jakie są korzyści ze stosowania próbkowania zaniżającego liczebność klasy większościowej?</h2>
<p>Wyrzucenie dużego procentu danych może być skuteczne w tworzeniu użytecznego modelu, który potrafi rozpoznać zarówno klasy większościowe, jak i mniejszościowe.</p>
<p>Podpróbkowanie prawie zawsze daje modele, które są lepiej skalibrowane, co oznacza, że rozkłady prawdopodobieństwa klas są lepiej zachowane. W rezultacie, domyślne odcięcie 50% daje znacznie większe prawdopodobieństwo uzyskania lepszych wartości czułości i specyficzności niż w innym przypadku.</p>
<p><br></p>
</section>
<section id="jakie-są-zalety-próbkowania-zawyżającego-liczebność-klasy-mniejszościowej" class="level2">
<h2 class="anchored" data-anchor-id="jakie-są-zalety-próbkowania-zawyżającego-liczebność-klasy-mniejszościowej">29. Jakie są zalety próbkowania zawyżającego liczebność klasy mniejszościowej?</h2>
<p>Techniki <em>oversamplingu</em> sprowadzają klasy mniejszościowe do liczebności takiej samej jak klasa większościowa (lub jej części) poprzez odpowiednie próbkowanie istniejących obserwacji lub też (jak to jest w przypadku metody SMOTE) tworzy się syntetyczne obserwacje podobne do już istniejących w klasie mniejszościowej. Jako zaletę można potraktować to, że w przeciwieństwie do <em>undersamplingu</em> nie zmniejszamy rozmiaru zbioru danych oraz przez co nie tracimy informacji, inne zalety pokrywają się z próbkowaniem w dół.</p>
<p><br></p>
</section>
<section id="jak-należy-stosować-poszczególne-kroki-przygotowania-danych-w-procesie-uczenia-i-walidacji-modelu" class="level2">
<h2 class="anchored" data-anchor-id="jak-należy-stosować-poszczególne-kroki-przygotowania-danych-w-procesie-uczenia-i-walidacji-modelu">30. Jak należy stosować poszczególne kroki przygotowania danych w procesie uczenia i walidacji modelu?</h2>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./Eksploracja_egzamin.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">Eksploracja Danych</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
  </div>
</nav>
</div> <!-- /content -->



</body></html>